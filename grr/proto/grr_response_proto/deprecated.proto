/**
 * NOTE: DO NOT USE PROTOBUFS FROM THIS FILE.
 *
 * This file contains definitions of deleted protos. They have to be preserved
 * so that newer versions of API client library can safely work with older
 * server releases.
 */
syntax = "proto2";

import "google/protobuf/any.proto";
import "grr_response_proto/anomaly.proto";
import "grr_response_proto/api/client.proto";
import "grr_response_proto/api/flow.proto";
import "grr_response_proto/artifact.proto";
import "grr_response_proto/jobs.proto";
import "grr_response_proto/knowledge_base.proto";
import "grr_response_proto/output_plugin.proto";
import "grr_response_proto/semantic.proto";
import "grr_response_proto/sysinfo.proto";

package grr;

message CollectArtifactDependenciesArgs {
  repeated string artifact_list = 1 [(sem_type) = {
    description: "A list of Artifact names to collect dependencies for.",
    type: "ArtifactName",
  }];
}

message ApiNotificationDiscoveryReference {
  optional string client_id = 1 [(sem_type) = {
    type: "ApiClientId",
    description: "The client this notification is about."
  }];
}

message ApiNotificationFileDownloadReference {
  optional string path = 1 [(sem_type) = {
    type: "RDFURN",
    description: "The download path for the file."
  }];
}

message ApiListCronJobFlowsArgs {
  optional string cron_job_id = 1
      [(sem_type) = { type: "ApiCronJobId", description: "Cron job id." }];
  optional int64 offset = 2 [(sem_type) = { description: "Starting offset." }];
  optional int64 count = 3
      [(sem_type) = { description: "Max number of flows to fetch." }];
}

message ApiGetCronJobFlowArgs {
  optional string cron_job_id = 1
      [(sem_type) = { type: "ApiCronJobId", description: "Cron job id." }];
  optional string flow_id = 2
      [(sem_type) = { type: "ApiFlowId", description: "Flow id." }];
}

message GlobalNotification {
  enum Type {
    INFO = 0;
    WARNING = 1;
    ERROR = 2;
  }
  optional Type type = 1;

  optional string header = 2;
  optional string content = 3;
  optional string link = 4;

  optional uint64 show_from = 5 [(sem_type) = {
    type: "RDFDatetime",
    description: "Notification will be shown after this time."
  }];
  optional uint64 duration = 6 [(sem_type) = {
    type: "DurationSeconds",
    description: "Duration of this notification."
  }];
}

message GlobalNotificationSet {
  repeated GlobalNotification notifications = 1;
}

message ApiListPendingGlobalNotificationsResult {
  repeated GlobalNotification items = 1 [
    (sem_type) = { description: "The list of pending global notifications." }
  ];
}

message ApiDeletePendingGlobalNotificationArgs {
  optional GlobalNotification.Type type = 1 [(sem_type) = {
    description: "The type of the global notification to delete."
  }];
}

message OutputPluginVerificationResult {
  optional string plugin_id = 1 [(sem_type) = {
    description: "String identifying the output plugin being checked."
  }];
  optional OutputPluginDescriptor plugin_descriptor = 2 [(sem_type) = {
    description: "Descriptor of the plugin that's being checked."
  }];

  enum Status {
    N_A = 0;
    SUCCESS = 1;
    WARNING = 2;
    FAILURE = 3;
  }
  optional Status status = 3;
  optional string status_message = 4;

  optional uint64 timestamp = 5 [
    (sem_type) = { type: "RDFDatetime", description: "Timestamp of the check." }
  ];
}

message OutputPluginVerificationResultsList {
  repeated OutputPluginVerificationResult results = 1;
}

message MemoryInformation {
  option (semantic) = {
    description: "Describe the memory geometry."
  };

  optional PathSpec device = 1;
  repeated BufferReference runs = 2;
  optional uint64 cr3 = 3;
}

message PluginRequest {
  optional string plugin = 2 [(sem_type) = {
    description: "The plugin name to run.",
  }];

  optional Dict args = 3 [(sem_type) = {
    description: "The args to the plugin.",
  }];
}

message RekallRequest {
  optional Iterator iterator = 1 [(sem_type) = { label: HIDDEN }];

  repeated PluginRequest plugins = 2 [(sem_type) = {
    description: "We can execute multiple plugins in the same session. "
                 "This can take advantage of caching in the session to be more efficient."
  }];

  optional PathSpec device = 4 [(sem_type) = {
    description: "The raw device to use.",
  }];

  optional Dict session = 6 [(sem_type) = {
    description: "These parameters are used to initialize the session.",
  }];

  repeated RekallProfile profiles = 9 [(sem_type) = {
    description: "Profiles sent by the server to store on the client.",
    label: HIDDEN
  }];
}

message RekallResponse {
  // Deprecated. Anything written in this field will be compressed and placed
  // into the compressed_json_messages field upon serialization.
  optional string json_messages = 1;
  optional bytes compressed_json_messages = 7
      [(sem_type) = { type: "ZippedJSONBytes" }];

  optional string json_context_messages = 5;

  optional string plugin = 2;

  optional string client_urn = 3 [(sem_type) = {
    type: "ClientURN",
    description: "The client this response comes from."
  }];

  optional string missing_profile = 4 [(sem_type) = {
    description: "Missing profiles that should be retrieved from "
                 "the server."
  }];

  optional string repository_version = 6 [
    (sem_type) = {
      description: "The version of the repository we want to use."
    },
    default = "v1.0"
  ];

  repeated string downloaded_files = 8 [(sem_type) = {
    description: "A list of downloaded files.",
    type: "RDFURN",
  }];
}

message RekallProfile {
  optional string name = 1
      [(sem_type) = { description: "The name of this profile." }];

  optional bytes data = 2
      [(sem_type) = { description: "A Rekall profile as a data blob." }];

  optional string version = 3
      [(sem_type) = { description: "The version of this profile." }];

  enum Compression {
    NONE = 0;
    GZIP = 1;
  }

  optional Compression compression = 4 [
    (sem_type) = {
      description: "Type of compression carried in the data field."
    },
    default = GZIP
  ];
}

message AnalyzeClientMemoryArgs {
  optional RekallRequest request = 2 [(sem_type) = {
    description: "A request for the client's Rekall subsystem.",
  }];

  optional bool debug_logging = 4 [
    (sem_type) = {
      description: "Use DEBUG level logging.",
      friendly_name: "DEBUG logging."
    },
    default = false
  ];

  optional uint64 max_file_size_download = 5 [
    (sem_type) = {
      description: "Obtain at most max_file_size_download bytes of each file "
                   "outputted by Rekall."
    },
    default = 35433480192
  ];  // 33 Gb

  optional string component_version = 6 [
    (sem_type) = {
      description: "The version of component to use.",
      label: ADVANCED,
    },
    default = "1.6.0"
  ];
}

message ApiListStatsStoreMetricsMetadataArgs {
  enum Component {
    WORKER = 0;
    FRONTEND = 1;
    ADMIN_UI = 2;
  }
  optional Component component = 1;
}

message ApiListStatsStoreMetricsMetadataResult {
  repeated MetricMetadata items = 1;
}

message ApiGetStatsStoreMetricArgs {
  enum Component {
    WORKER = 0;
    FRONTEND = 1;
    ADMIN_UI = 2;
  }
  optional Component component = 1;
  optional string metric_name = 2;

  optional uint64 start = 3 [(sem_type) = {
    type: "RDFDatetime",
    description: "Fetch metrics data starting from this timestamp. If "
                 "not set, will default to 1 hour ago."
  }];
  optional uint64 end = 4 [(sem_type) = {
    type: "RDFDatetime",
    description: "Fetch metrics data from the interval ending with "
                 "this timestamp. If not set, will default to the current time."
  }];

  optional uint64 rate = 7 [(sem_type) = {
    type: "DurationSeconds",
    description: "If set, metric's rate over given window will be returned "
                 "instead of plain values."
  }];

  enum DistributionHandlingMode {
    DH_SUM = 0 [(description) = "Sum of all values recorded in a distribution "
                                "will be fetched."];
    DH_COUNT = 1
        [(description) = "Number of all values recorded in a distribution "
                         "will be fetched."];
  }
  optional DistributionHandlingMode distribution_handling_mode = 5 [(sem_type) = {
    description: "Determines which values to fetch when dealing with distributions."
  }];

  enum AggregationMode {
    AGG_SUM = 0 [(description) = "Values will be summed."];
    AGG_MEAN = 1 [(description) = "Mean value will be calculated."];
    AGG_NONE = 2 [(description) = "No aggregation will be performed."];
  }
  optional AggregationMode aggregation_mode = 6 [(sem_type) = {
    description: "Aggregation method. As metrics are usually collected across "
                 "multiple processes, most of the time they have to be aggregated."
  }];
}

message StatsStoreFieldValue {
  optional MetricFieldDefinition.FieldType field_type = 1;

  optional string str_value = 2;
  optional int64 int_value = 3;
}

message StatsStoreValue {
  optional MetricMetadata.ValueType value_type = 1;

  optional string str_value = 2;
  optional int64 int_value = 3;
  optional float float_value = 4;
  optional Distribution distribution_value = 5;

  repeated StatsStoreFieldValue fields_values = 6;
}

message StatsStoreEntry {
  optional string process_id = 1 [(sem_type) = {
    description: "Stats identifier for the monitored process, e.g 'frontend_2'."
  }];
  optional string metric_name = 2
      [(sem_type) = { description: "Name of the metric." }];
  optional StatsStoreValue metric_value = 3 [(sem_type) = {
    description: "Value of the metric at a given point in time."
  }];
  optional uint64 timestamp = 4 [(sem_type) = {
    type: "RDFDatetime",
    description: "Timestamp for when the metric value was observed.",
  }];
}

message ApiAff4AttributeDescriptor {
  optional string name = 1;
}

message ApiListAff4AttributeDescriptorsResult {
  repeated ApiAff4AttributeDescriptor items = 1;
}

// Next field: 9
message ACLToken {
  optional string username = 1;

  // A reason for access (e.g. case name, investigation id).
  optional string reason = 2;

  reserved 3;

  optional uint64 expiry = 5 [(sem_type) = {
    type: "RDFDatetime",
    description: "When does this token expire?",
  }];

  // The IP this request originated from as well as proxies on the way.
  repeated string source_ips = 6;

  // The issuing process.
  optional string process = 7;

  reserved 8;
}

message PendingFlowTermination {
  reserved 1;
}

message PlistValueFilterArgs {
  optional PlistRequest request = 1;
}

message PlistRequest {
  optional PathSpec pathspec = 1;
  optional string context = 2;
  optional string query = 3;
}


enum Match {
  // Quantifies how many results indicate a problem.
  NONE = 0;  // No tested items match.
  ONE = 1;   // Only one tested item matches.
  ANY = 2;   // One or more tested items match.
  ALL = 3;   // All tested items match.
  SOME = 4;  // More than one tested item matches.
}

message Check {
  optional string check_id = 1;
  repeated Method method = 2;
  repeated Match match = 3;
  optional Target target = 4;
  optional Hint hint = 5;
}

message Method {
  repeated Probe probe = 1;
  repeated Match match = 2;
  repeated Dict resource = 3;
  optional Target target = 4;
  optional Hint hint = 5;
}

message Probe {
  enum Mode {
    SERIAL = 0;
    PARALLEL = 1;
  }
  enum ResultContext {
    UNKNOWN_RESULT_CONTEXT = 0;
    PARSER = 1;
    ANOMALY = 2;
    RAW = 3;
  }
  optional string artifact = 1;
  repeated string parser = 2;
  optional Mode mode = 3;
  repeated Filter baseline = 4;
  repeated Filter filters = 5;
  repeated Match match = 6;
  optional Target target = 7;
  optional Hint hint = 8;
  optional ResultContext result_context = 9;
}

message Filter {
  optional string type = 1;
  optional string expression = 2;
  optional Hint hint = 5;
}

message CheckResult {
  optional string check_id = 1;
  repeated Anomaly anomaly = 2;
}

message CheckResults {
  optional KnowledgeBase kb = 1;
  repeated CheckResult result = 2;
}

message Hint {
  optional string problem = 1;
  optional string fix = 2;
  optional string format = 3;
  optional string summary = 4;
  optional uint64 max_results = 5;
}

message Target {
  repeated string cpe = 1;
  repeated string os = 2;
  repeated string label = 3;
}

message CheckFlowArgs {
  repeated string only_os = 1;
  repeated string only_cpe = 2;
  repeated string only_label = 3;
  repeated uint64 max_findings = 4;
  repeated string restrict_checks = 5;
}

message CAEnrolerArgs {
  optional Certificate csr = 1;
}

message CollectSingleFileArgs {
  optional string path = 1;
  optional uint64 max_size_bytes = 2 [(sem_type) = { type: "ByteSize" }];
}

message CollectSingleFileResult {
  optional StatEntry stat = 1;
  optional Hash hash = 2;
}

message CollectSingleFileProgress {
  enum Status {
    UNDEFINED = 0;
    IN_PROGRESS = 1;
    COLLECTED = 2;
    NOT_FOUND = 3;
    FAILED = 4;
  }
  optional Status status = 1;
  optional CollectSingleFileResult result = 2;
  optional string error_description = 3;
}

message ClientActionRequest {
  optional string client_id = 1;
  optional string flow_id = 2;
  optional uint64 request_id = 3;
  optional string action_identifier = 4;
  optional google.protobuf.Any action_args = 5;
  optional uint64 cpu_limit_ms = 6;
  optional uint64 network_bytes_limit = 7;
  optional uint64 runtime_limit_us = 52;
}

message ApiClientActionRequest {
  optional uint64 task_id = 1;
  optional uint64 leased_until = 2;
  optional string session_id = 3;
  optional string client_action = 4;
  repeated GrrMessage responses = 5;
}

message ApiListClientActionRequestsArgs {
  optional string client_id = 1;
  optional bool fetch_responses = 2;
}

message ApiListClientActionRequestsResult {
  repeated ApiClientActionRequest items = 1;
}

message UninstallArgs {
  optional bool kill = 1 [(sem_type) = {
    description: "Kills the client if set.",
  }];
}

message KeepAliveArgs {
  optional uint64 duration = 1 [
    (sem_type) = {
      type: "DurationSeconds",
      description: "Until when should the client stay in the fast poll mode.",
    },
    default = 3600
  ];
}

message CollectEfiHashesResponse {
  optional string eficheck_version = 1;
  optional string boot_rom_version = 2;
  optional ExecuteBinaryResponse response = 3;
}

message DumpEfiImageResponse {
  optional string eficheck_version = 1;
  optional PathSpec path = 2 [(sem_type) = {
    description: "Temporary path to the flash image.",
  }];
  optional ExecuteBinaryResponse response = 3;
}

message EficheckConfig {
  reserved 1;
  optional string cmd_path = 2;
}

message EficheckFlowArgs {
  reserved 1;
  optional string cmd_path = 2
      [default = "/usr/libexec/firmwarecheckers/eficheck/eficheck"];
}

message EfiCollection {
  optional string eficheck_version = 1 [(sem_type) = {
    description: "Version of eficheck used to collect the data."
  }];
  optional string boot_rom_version = 2
      [(sem_type) = { description: "Boot ROM version." }];
  repeated EfiEntry entries = 3
      [(sem_type) = { description: "The hashes of the collection." }];
}

message EfiEntry {
  optional uint32 volume_type = 1
      [(sem_type) = { description: "The volume type." }];
  optional uint64 address = 2
      [(sem_type) = { description: "The entry address." }];
  optional uint32 size = 3 [(sem_type) = { description: "The entry size." }];
  optional string guid = 4 [(sem_type) = { description: "The EFI GUID." }];
  optional string hash = 5 [(sem_type) = { description: "The hash value." }];
  optional uint32 flags = 6 [(sem_type) = {
    description: "A bit field of flags that describe the volume "
                 "(known=1, volatile=2, ffs=4)."
  }];
  optional uint32 index = 7
      [(sem_type) = { description: "The entry's volume index." }];
}

message FindFilesArgs {
  reserved 3, 4;

  optional FindSpec findspec = 1 [(sem_type) = {
    description: "A find operation specification.",
  }];
}

message SendFileRequest {
  optional PathSpec pathspec = 1 [(sem_type) = {
    description: "The pathspec for the file to retrieve.",
  }];

  optional NetworkAddress.Family address_family = 2 [
    (sem_type) = {
      description: "address family to use (AF_INET or AF_INET6).",
    },
    default = INET
  ];

  optional string host = 3 [(sem_type) = {
    description: "Hostname or IP to send the file to.",
  }];

  optional uint64 port = 4 [
    (sem_type) = {
      description: "Port number on the listening server.",
    },
    default = 12345
  ];

  optional bytes key = 5 [(sem_type) = {
    type: "AES128Key",
    description: "An encryption key given in hex representation.",
  }];

  optional bytes iv = 6 [(sem_type) = {
    type: "AES128Key",
    description: "The iv for AES, also given in hex representation.",
  }];
}

message FingerprintFileArgs {
  optional PathSpec pathspec = 1 [(sem_type) = {
    description: "The file path to fingerprint.",
  }];
}

message FingerprintFileResult {
  optional string file_urn = 1 [(sem_type) = {
    type: "RDFURN",
    description: "The URN of the file fingerprinted",
  }];
  optional Hash hash_entry = 2 [(sem_type) = {
    description: "File hash object.",
  }];
}

message ApiStatsStoreMetricDataPoint {
  optional uint64 timestamp = 1 [(sem_type) = {
    type: "RDFDatetime",
    description: "Timestamp of the data point."
  }];
  optional double value = 2
      [(sem_type) = { description: "Value corresponding to the timestamp." }];
}

message ApiStatsStoreMetric {
  optional string metric_name = 1;
  optional uint64 start = 2 [(sem_type) = {
    type: "RDFDatetime",
  }];
  optional uint64 end = 3 [(sem_type) = {
    type: "RDFDatetime",
  }];
  repeated ApiStatsStoreMetricDataPoint data_points = 4;
}

message ApiGetClientLoadStatsArgs {
  optional string client_id = 1
      [(sem_type) = { type: "ApiClientId", description: "Client id." }];

  optional uint64 start = 2 [(sem_type) = {
    type: "RDFDatetime",
    description: "Fetch client load stats data starting from this "
                 "timestamp. If not set, will default to 30 minutes ago."
  }];
  optional uint64 end = 3 [(sem_type) = {
    type: "RDFDatetime",
    description: "Fetch client load stats data from the interval "
                 "ending with this timestamp. If not set, will default to the current "
                 "time."
  }];

  enum Metric {
    CPU_PERCENT = 0;
    CPU_SYSTEM = 1;
    CPU_USER = 2;

    IO_READ_BYTES = 3;
    IO_WRITE_BYTES = 4;
    IO_READ_OPS = 5;
    IO_WRITE_OPS = 6;

    NETWORK_BYTES_RECEIVED = 7;
    NETWORK_BYTES_SENT = 8;

    MEMORY_PERCENT = 9;
    MEMORY_RSS_SIZE = 10;
    MEMORY_VMS_SIZE = 11;
  }
  optional Metric metric = 5;
}

message ApiGetClientLoadStatsResult {
  repeated ApiStatsStoreMetricDataPoint data_points = 1;
}

message ExpandedArtifact {
  required string name = 1 [(sem_type) = {
    description: "The name of the artifact.",
    type: "ArtifactName",
  }];
  repeated ExpandedSource sources = 2
      [(sem_type) = { description: "The sources and what they depend on." }];
  repeated string provides = 3 [(sem_type) = {
    description: "A list of knowledgebase values this artifact provides.",
  }];
  optional bool requested_by_user = 4 [
    (sem_type) = {
      description: "Whether the artifact is requested by the user or scheduled"
                   " for collection as a KnowledgeBase dependency."
    },
    default = true
  ];
}

message ExpandedSource {
  required ArtifactSource base_source = 1
      [(sem_type) = { description: "The base source." }];
  optional PathSpec.PathType path_type = 6
      [(sem_type) = { description: "Path Type" }];
  optional uint64 max_bytesize = 7 [(sem_type) = {
    type: "ByteSize",
    description: "File Finder Download Action Option: The maximum byte size of "
                 "files we will download."
  }];
  optional int32 max_number_files = 8 [(sem_type) = {
    description: "File Finder Action Option: The maximum number of "
                 "results to get."
  }];
  repeated ExpandedSource artifact_sources = 9 [(sem_type) = {
    description: "Extended sources for ArtifactFiles collection."
  }];
}

message ClientArtifactCollectorResult {
  repeated CollectedArtifact collected_artifacts = 1 [(sem_type) = {
    description: "The results of the single collected artifacts."
  }];
  optional KnowledgeBase knowledge_base = 2 [(sem_type) = {
    description: "The knowledge base containing information about the client."
  }];
}

message CollectedArtifact {
  required string name = 1 [(sem_type) = {
    description: "The name of the artifact.",
    type: "ArtifactName",
  }];
  repeated ClientActionResult action_results = 2 [(sem_type) = {
    description: "The results from the performed client actions."
  }];
}

message ClientArtifactCollectorArgs {
  repeated ExpandedArtifact artifacts = 1
      [(sem_type) = { description: "A list of artifacts." }];
  optional KnowledgeBase knowledge_base = 2 [(sem_type) = {
    description: "The knowledge base containing information about the client."
  }];
  // Removed, since it wasn't used.
  // optional bool use_tsk = 3
  reserved 3;
  optional bool apply_parsers = 6 [
    (sem_type) = {
      description: "If True, apply any relevant parser to the collected data. "
                   "If False, return the raw collected data e.g. Files or Registry Keys.",
      label: ADVANCED,
    },
    default = true
  ];
  optional bool ignore_interpolation_errors = 7 [
    (sem_type) = {
      description: "If true, don't die if %%users.homedir%% and similar fail"
                   " to expand. It's common on windows for some user attributes to be"
                   " missing if users have never logged in. Enable this when you have"
                   " multiple artifacts or paths and want to report partial results.",
    },
    default = false
  ];
  optional uint64 max_file_size = 8 [
    (sem_type) = {
      type: "ByteSize",
      description: "The maximum size of files we will download in bytes,"
                   " 500MB by default.",
      label: ADVANCED
    },
    default = 500000000
  ];
}

message ApiStackChartReportData {
  repeated ApiReportDataSeries2D data = 1
      [(sem_type) = { description: "What the report contains." }];

  repeated ApiReportTickSpecifier x_ticks = 2 [(sem_type) = {
    description: "X axis ticks. See: github.com/flot/flot/blob/master/API.md"
  }];

  repeated ApiReportTickSpecifier y_ticks = 3 [(sem_type) = {
    description: "Y axis ticks. See: github.com/flot/flot/blob/master/API.md"
  }];

  optional float bar_width = 4 [
    (sem_type) = { description: "Width of the bars displayed on the chart." }
  ];
}

message ApiPieChartReportData {
  repeated ApiReportDataPoint1D data = 1
      [(sem_type) = { description: "What the report contains." }];
}

message ApiLineChartReportData {
  repeated ApiReportDataSeries2D data = 1
      [(sem_type) = { description: "What the report contains." }];
}

message ApiReportDataPoint1D {
  optional float x = 1;

  optional string label = 2
      [(sem_type) = { description: "The series is labeled with this string." }];
}

message ApiReportDataSeries2D {
  optional string label = 1
      [(sem_type) = { description: "The series is labeled with this string." }];

  repeated ApiReportDataPoint2D points = 2;
}

message ApiReportDataPoint2D {
  optional float x = 1;
  optional float y = 2;
}

message ApiReportTickSpecifier {
  optional float x = 1;
  optional string label = 2;
}

message ChromeHistoryArgs {
  optional PathSpec.PathType pathtype = 1 [
    (sem_type) = { description: "Type of path access to use." },
    default = OS
  ];

  optional bool get_archive = 2 [(sem_type) = {
    description: "Should we get Archived History as well (3 months old)."
  }];

  optional string username = 3 [(sem_type) = {
    description: "The user to get Chrome history for. If history_path is "
                 "not set this will be used to guess the path to the "
                 "history files. Can be in form DOMAIN\\user.",
  }];

  optional string history_path = 5 [(sem_type) = {
    description: "Path to a profile directory that contains a History "
                 "file.",
  }];
}

message FirefoxHistoryArgs {
  optional PathSpec.PathType pathtype = 1 [
    (sem_type) = { description: "Type of path access to use." },
    default = OS
  ];

  optional bool get_archive = 2 [
    (sem_type) = {
      description: "Should we get Archived History as well (3 months old).",
    },
    default = false
  ];

  optional string username = 3 [(sem_type) = {
    description: "The user to get history for. If history_path is "
                 "not set this will be used to guess the path to the "
                 "history files. Can be in form DOMAIN\\user."
  }];

  optional string history_path = 5 [(sem_type) = {
    description: "Path to a profile directory that contains a History file.",
  }];
}

message PCIDevice {
  // Location of PCI device on the system.
  optional uint32 domain = 1 [(sem_type) = {
    description: "PCI domain this device is in.",
  }];
  optional uint32 bus = 2 [(sem_type) = {
    description: "8 bit PCI bus this device is on.",
  }];
  optional uint32 device = 3 [(sem_type) = {
    description: "5 bit device location on the bus.",
  }];
  optional uint32 function = 4 [(sem_type) = {
    description: "3 bit device function that has been mapped.",
  }];

  // Information from the PCI device itself.
  optional string class_id = 5 [(sem_type) = {
    description: "Hex string of 24 bit device class ID (e.g. Display).",
  }];
  optional string vendor = 6 [(sem_type) = {
    description: "Hex string of 16 bit device vendor ID.",
  }];
  optional string vendor_device_id = 7 [(sem_type) = {
    description: "Hex string of 16 bit device ID as set by the vendor.",
  }];
  // This is stored as bytes to preserve data as-is.
  optional bytes config = 8 [(sem_type) = {
    description: "64 to 256 bytes of PCI configuration space header.",
  }];
}

message SshdMatchBlock {
  optional string criterion = 1 [(sem_type) = {
    description: "Criteria that trigger a match block.",
  }];
  optional AttributedDict config = 2 [(sem_type) = {
    description: "The configuration of the match block.",
  }];
}

message SshdConfig {
  optional AttributedDict config = 1 [(sem_type) = {
    description: "The main sshd configuration.",
  }];
  repeated SshdMatchBlock matches = 2 [(sem_type) = {
    description: "Match block sections.",
  }];
}

message SudoersAlias {
  enum Type {
    USER = 0;
    RUNAS = 1;
    HOST = 2;
    CMD = 3;
  }

  optional Type type = 1 [(sem_type) = { description: "Alias type." }];
  optional string name = 2 [(sem_type) = { description: "Alias name." }];

  repeated string users = 3 [(sem_type) = {
    description: "User list, if type is USER.",
  }];
  repeated string runas = 4 [(sem_type) = {
    description: "Runas list, if type is RUNAS.",
  }];
  repeated string hosts = 5 [(sem_type) = {
    description: "Host list, if type is HOST.",
  }];
  repeated string cmds = 6 [(sem_type) = {
    description: "Command list, if type is CMD.",
  }];
}

message SudoersDefault {
  optional string scope = 1 [(sem_type) = {
    description: "Scope for this default (eg, >root).",
  }];
  optional string name = 2 [(sem_type) = {
    description: "Name for the default, including negations (!).",
  }];
  optional string value = 3 [(sem_type) = {
    description: "Value for the default, if one exists.",
  }];
}

message SudoersEntry {
  repeated string users = 1 [(sem_type) = {
    description: "Users this rule applies to.",
  }];
  repeated string hosts = 2 [(sem_type) = {
    description: "Hosts this rule applies to (optional).",
  }];
  repeated string cmdspec = 3 [(sem_type) = {
    description: "All content after the '=' in the sudoers rule.",
  }];
}

message SudoersConfig {
  repeated SudoersDefault defaults = 1 [(sem_type) = {
    description: "Default settings (binary options or key/value pairs).",
  }];
  repeated SudoersAlias aliases = 2 [(sem_type) = {
    description: "Aliases within a sudoers file.",
  }];
  repeated SudoersEntry entries = 3 [(sem_type) = {
    description: "Entries within a sudoers file.",
  }];
  repeated string includes = 4 [(sem_type) = {
    description: "Includes within a sudoers file.",
  }];
}

message DiskVolumeInfoArgs {
  repeated string path_list = 1 [(sem_type) = {
    description: "List of paths.",
  }];

  optional PathSpec.PathType pathtype = 2 [
    (sem_type) = {
      description: "Type of path. Only OS is currently supported.",
      label: HIDDEN,
    },
    default = OS
  ];
}

message LinuxServiceInformation {
  option (semantic) = {
    description: "Describe an Linux service (init/upstart/systemd).",
  };

  optional string name = 1 [(sem_type) = {
    description: "The name of the service.",
  }];

  optional string description = 2 [(sem_type) = {
    description: "The description string of the service.",
  }];

  optional StatEntry binary = 3 [(sem_type) = {
    description: "The binary on the client. This may also contain an AFF4 "
                 "urn to the server copy of the same file.",
  }];

  optional SoftwarePackage software = 4 [(sem_type) = {
    description: "Software package that deployed the service.",
  }];

  enum StartMode {
    UNKNOWN = 0;
    INIT = 1;
    UPSTART = 2;
    SYSTEMD = 3;
    INETD = 4;
    XINETD = 5;
  }

  optional StartMode start_mode = 5 [(sem_type) = {
    description: "Service start options",
  }];

  repeated uint32 start_on = 6 [(sem_type) = {
    description: "Specifies the runlevels where this service runs.",
  }];

  repeated uint32 stop_on = 7 [(sem_type) = {
    description: "Specifies the runlevels where this service is stopped.",
  }];

  repeated string start_after = 8 [(sem_type) = {
    description: "Specifies services required before this service runs.",
  }];

  repeated string stop_after = 9 [(sem_type) = {
    description: "Specifies service required before this service is stopped.",
  }];

  optional AttributedDict config = 10 [(sem_type) = {
    description: "The configuration of the service.",
  }];

  optional bool starts = 11 [(sem_type) = {
    description: "The service is configured to start up through some means.",
  }];
}

message WindowsServiceInformation {
  option (semantic) = {
    description: "Describe a windows service or driver. Field names follow"
                 " the cybox naming scheme where possible: "
                 "http://cybox.mitre.org/language/version2.0.1/xsddocs/objects/Win_Service_Object.html",
  };

  optional string name = 1 [(sem_type) = {
    description: "The name of the service.",
  }];

  optional string description = 2 [(sem_type) = {
    description: "The description string of the service.",
  }];

  optional StatEntry binary = 3 [(sem_type) = {
    description: "The binary on the client. This may also contain an AFF4 "
                 "urn to the server copy of the same file.",
  }];

  optional string state = 4 [(sem_type) = {
    description: "Current state of the service.",
  }];

  optional Dict wmi_information = 5 [(sem_type) = {
    description: "Additional information available through WMI.",
  }];

  optional string display_name = 6 [(sem_type) = {
    description: "Displayed name of the service in Windows GUI controls.",
  }];

  optional string driver_package_id = 7 [(sem_type) = {
    description: "Driver Package ID of the service.",
  }];

  enum ErrorControl {
    CRITICAL = 3;
    SEVERE = 2;
    NORMAL = 1;
    IGNORE = 0;
  }

  optional ErrorControl error_control = 8 [(sem_type) = {
    description: "Behaviour of the service on failure to load/initialize",
  }];

  optional string image_path = 9 [(sem_type) = {
    description: "ImagePath of the service.",
  }];

  optional string object_name = 10 [(sem_type) = {
    description: "ObjectName of the service.",
  }];

  enum ServiceMode {
    SERVICE_BOOT_START = 0;
    SERVICE_SYSTEM_START = 1;
    SERVICE_AUTO_START = 2;
    SERVICE_DEMAND_START = 3;
    SERVICE_DISABLED = 4;
  }

  optional ServiceMode startup_type = 11 [(sem_type) = {
    description: "Service start options",
  }];

  enum ServiceType {
    SERVICE_KERNEL_DRIVER = 0x1;
    SERVICE_FILE_SYSTEM_DRIVER = 0x2;
    SERVICE_ADAPTER_ARGS = 0x4;
    SERVICE_RECOGNIZER_DRIVER = 0x8;
    SERVICE_WIN32_OWN_PROCESS = 0x10;
    SERVICE_WIN32_SHARE_PROCESS = 0x20;
    SERVICE_USER_OWN_PROCESS = 0x50;
    SERVICE_USER_SHARE_PROCESS = 0x60;
    SERVICE_INTERACTIVE_PROCESS = 0x100;
    SERVICE_INSTANCE_USER_SHARE_PROCESS = 0xe0;
    SERVICE_INTERACTIVE_WIN32_OWN_PROCESS = 0x110;
    SERVICE_INTERACTIVE_WIN32_SHARE_PROCESS = 0x120;
  }

  optional ServiceType service_type = 12 [(sem_type) = {
    description: "Type of the service.",
  }];

  optional string group_name = 13 [(sem_type) = {
    description: "Specifies the name of the load ordering group of which "
                 "this service is a member.",
  }];

  optional string service_dll = 14 [(sem_type) = {
    description: "Name of the DLL instantiated in the service.",
  }];

  optional string registry_key = 15
      [(sem_type) = { description: "The service registry key." }];
}

// Condition to match on OS.
message OSCondition {
  // Enum defining how the condition can be matched.
  enum ComparisonType {
    UNKNOWN = 0 [(description) = "Unknown"];
    EQUALS = 1 [(description) = "Equals"];
    NOT_EQUALS = 2 [(description) = "Not Equals"];
    CONTAINS = 3 [(description) = "Substring"];
  }
  // How to match the supplied OS string.
  optional ComparisonType comparison_type = 1;

  // OS string to match.
  optional string os = 2;
}

// Condition expression.
message ConditionExpression {
  option (semantic) = {
    union_field: "condition_type"
  };

  // Enum for all the operators and conditions.
  enum ConditionType {
    UNKNOWN = 0 [(description) = "Unknown"];
    OS = 1 [(description) = "OS condition"];
  }

  // Type of the condition.
  optional ConditionType condition_type = 1;

  // OS condition.
  optional OSCondition os_condition = 2;
}

// Negation of the containing expression.
message NotExpression {
  // Expression to negate.
  optional SearchExpression expression = 1;
}

// Conjunction of two expressions.
message AndExpression {
  // First operand.
  optional SearchExpression left_operand = 1;
  // Second operand.
  optional SearchExpression right_operand = 2;
}

// Disjunction of two expressions.
message OrExpression {
  // First operand.
  optional SearchExpression left_operand = 1;
  // Second operand.
  optional SearchExpression right_operand = 2;
}

// Structured search expression.
message SearchExpression {
  option (semantic) = {
    union_field: "expression_type"
  };

  // Enum for all the operators and conditions.
  enum ExpressionType {
    UNKNOWN = 0 [(description) = "Unknown"];
    NEGATION = 1 [(description) = "Negation expression"];
    AND = 2 [(description) = "AND expression"];
    OR = 3 [(description) = "OR expression"];
    CONDITION = 4 [(description) = "Condition expression"];
  }

  // Type of the expression.
  optional ExpressionType expression_type = 1;
  // Negation expression.
  optional NotExpression not_expression = 2;
  // Conjunction expression.
  optional AndExpression and_expression = 3;
  // Disjunction expression.
  optional OrExpression or_expression = 4;
  // Condition expression.
  optional ConditionExpression condition_expression = 5;
}

message SortOrder {
  enum OrderBy {
    UNKNOWN = 0 [(description) = "Unknown"];
    SNAPSHOT_CREATION_TIME = 1
        [(description) = "Order by when the snapshot was created"];
  }

  // What to order the results by.
  optional OrderBy order_by = 1;

  enum Order {
    UNKNOWN_ORDER = 0 [(description) = "Unknown order"];
    ASCENDING = 1 [(description) = "Ascending order"];
    DESCENDING = 2 [(description) = "Descending order"];
  }

  // In what order the results should be in.
  optional Order order = 2;
}

message ApiStructuredSearchClientsArgs {
  optional SearchExpression expression = 1
      [(sem_type) = { description: "Structured search expression" }];
  optional SortOrder sort_order = 2
      [(sem_type) = { description: "Structured search order" }];
  optional bytes continuation_token = 3
      [(sem_type) = { description: "Continuation token for pagination." }];
  optional uint64 number_of_results = 4
      [(sem_type) = { description: "Number of clients to fetch." }];
}

message ApiStructuredSearchClientsResult {
  repeated ApiClient items = 1;
  optional bytes continuation_token = 2;
  optional uint64 estimated_count = 3 [(sem_type) = {
    description: "Estimated number of found clients matching query."
  }];
}

message ArtifactFallbackCollectorArgs {
  optional string artifact_name = 1 [(sem_type) = {
    description: "Name of the artifact using this fallback.",
    type: "ArtifactName",
  }];
}

message ApiGetFileDecodersArgs {
  optional string client_id = 1 [(sem_type) = {
    type: "ApiClientId",
    description: "An id of the client to which the encoded file belongs to."
  }];
  optional string file_path = 2 [(sem_type) = {
    description: "A path to the encrypted file to get the decoder names for."
  }];
  // TODO(hanuszczak): Add support for listing decoders for a file as observed
  // at specific timestamp.
}

message ApiGetFileDecodersResult {
  repeated string decoder_names = 1 [(sem_type) = {
    description: "Names of the decoders that are applicable to the file."
  }];
}

message ApiGetDecodedFileArgs {
  optional string client_id = 1 [(sem_type) = {
    type: "ApiClientId",
    description: "An id of the client to which the encoded file belongs to."
  }];
  optional string file_path = 2 [(sem_type) = {
    description: "A path to the encrypted file to do the decoding on."
  }];
  optional string decoder_name = 3 [(sem_type) = {
    description: "A name of the decoder to use to decoder the file."
  }];
  // TODO(hanuszczak): Add support for decoding file content as observed at
  // specific timestamp.
}

// Arguments for the API method that retrieves descriptors of all parsers that
// are applicable to the results of the specified artifact collector flow.
message ApiListFlowApplicableParsersArgs {
  // An identifier of the client of the flow to list the parsers for.
  optional string client_id = 1 [(sem_type) = { type: "ApiClientId" }];

  // An identifier of the flow to list the parsers for.
  optional string flow_id = 2 [(sem_type) = { type: "ApiFlowId" }];
}

// Results for the API method that retrieves descriptors of all parsers that are
// applicable to the results of the specified artifact collector flow.
message ApiListFlowApplicableParsersResult {
  // Descriptors of all applicable parsers.
  //
  // Note that if the flow parsed its results already during its execution (i.e.
  // it is not a flow with on-demand parsing) the list of parsers is going to be
  // empty.
  repeated ApiParserDescriptor parsers = 1;
}

// Describes a single parser registered within the system that processes results
// of the artifact collector flow (if applicable).
message ApiParserDescriptor {
  // Enumeration of all parser types.
  enum Type {
    // An unknown parser.
    UNKNOWN = 0;
    // A parser that is able to parse a single response.
    SINGLE_RESPONSE = 1;
    // A parser that parses all responses at once.
    MULTI_RESPONSE = 2;
    // A parser that is able to parse contents of a single collected file.
    SINGLE_FILE = 3;
    // A parser that parses contents of all collected files at once.
    MULTI_FILE = 4;
  }

  // A name under which the parser is registered in the system.
  optional string name = 1;

  // A type of the parser.
  optional Type type = 2;
}

// Arguments for the API method that parses results of the artifact collection
// flow on the fly.
message ApiListParsedFlowResultsArgs {
  // An identifier of the client of the flow to parse the responses for.
  optional string client_id = 1 [(sem_type) = { type: "ApiClientId" }];

  // An identifier of the flow to parse the responses for.
  optional string flow_id = 2 [(sem_type) = { type: "ApiFlowId" }];

  // An offset of the flow results to parse.
  optional uint64 offset = 3;

  // Number of flow results to parse.
  //
  // Note that the number of parsed responses can be different as a single flow
  // result can be parsed into zero or more items.
  optional uint64 count = 4;
}

// Results of the API method that parses results of the artifact collection flow
// on the fly.
message ApiListParsedFlowResultsResult {
  // A collection of parsed flow results.
  //
  // Note that a single original flow response can result in multiple parsed
  // flow responses.
  repeated ApiFlowResult items = 1;

  // A collection of parse errors.
  //
  // Note that having some values here does not necessarily mean that no items
  // are returned: parsing one response can lead to an error, but parsing other
  // one can succeed.
  repeated string errors = 2;
}

message ArtifactProcessorDescriptor {
  optional string name = 1;
  optional string description = 2;
  repeated string output_types = 3;
}
