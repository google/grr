

// The following messages are used in GRR's web API.

syntax = "proto2";

import "google/protobuf/any.proto";

import "grr/proto/analysis.proto";
import "grr/proto/artifact.proto";
import "grr/proto/flows.proto";
import "grr/proto/jobs.proto";
import "grr/proto/knowledge_base.proto";
import "grr/proto/output_plugin.proto";
import "grr/proto/semantic.proto";
import "grr/proto/sysinfo.proto";



//
// API call handlers arguments (see gui/api_call_handlers.py).
//

message ApiAuthorization {
  optional string router = 1 [(sem_type) = {
      description: "api_call_router.ApiCallRouter class name that this "
                   "authorization applies to."
    }];
  optional ApiDataObject router_params = 4 [(sem_type) = {
      description: "Router configuration. Will be passed to router "
      "constructor as keyword arguments."
    }];

  repeated string users = 2 [(sem_type) = {
      description: "List of users that will use a given API router."
    }];
  repeated string groups = 3[(sem_type) = {
      description: "List of groups that will use a given API router."
    }];
}

message ApiSearchClientsArgs {
  optional string query = 1 [(sem_type) = {
      description: "Search query string. See here for syntax: "
      "https://github.com/google/grr-doc/blob/master/"
      "user_manual.adoc#searching-for-a-client"
  }];
  optional int64 offset = 2 [(sem_type) = {
      description: "Found clients starting offset."
    }];
  optional int64 count = 3 [(sem_type) = {
      description: "Number of found client to fetch."
    }];
}

message ApiSearchClientsResult {
  repeated ApiClient items = 1;
}

message ApiGetClientArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional uint64 timestamp = 2 [(sem_type) = {
      type: "RDFDatetime",
      description: "Timestamp of the client."
    }];
}

message ApiGetClientVersionTimesArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
}

message ApiGetClientVersionTimesResult {
  repeated uint64 times = 1 [(sem_type) = {
      type: "RDFDatetime",
      description: "The list of version times."
    }];
}

message ApiInterrogateClientArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
}

message ApiInterrogateClientResult {
  optional string operation_id = 1 [(sem_type) = {
      description: "The id of the interrogate operation."
    }];
}

message ApiGetInterrogateOperationStateArgs {
  optional string operation_id = 1 [(sem_type) = {
      description: "The id of the interrogate operation."
    }];
}

message ApiGetInterrogateOperationStateResult {
  enum State {
    RUNNING = 0;
    FINISHED = 1;
  }

  optional State state = 1 [(sem_type) = {
      description: "The state of the interrogate operation."
    }];
}

message ApiGetLastClientIPAddressArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
}

message ApiGetLastClientIPAddressResult {
  enum Status {
    UNKNOWN = 0;
    INTERNAL = 1;
    EXTERNAL = 2;
    VPN = 3;
  }

  optional string ip = 1 [(sem_type) = {
      description: "The ip the client used for the latest communication."
    }];
  optional string info = 2 [(sem_type) = {
      description: "Additional info about the ip address."
    }];
  optional Status status = 3 [(sem_type) = {
      description: "The status of the ip address."
    }];
}

message ApiListClientCrashesArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional int64 offset = 2 [(sem_type) = {
      description: "Client crashes starting offset."
    }];
  optional int64 count = 3 [(sem_type) = {
      description: "Max number of crashes to fetch."
    }];
  optional string filter = 4 [(sem_type) = {
      description: "Return only results whose string representation "
      "contains given substring."
    }];
}

message ApiListClientCrashesResult {
  repeated ClientCrash items = 1 [(sem_type) = {
    description: "The client crashes"
  }];
  optional int64 total_count = 2 [(sem_type) = {
    description: "Total count of items."
  }];
}

message ApiGetFlowArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string flow_id = 2 [(sem_type) = {
      type: "ApiFlowId",
      description: "Flow id."
    }];
}

message ApiCreateFlowArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional ApiFlow flow = 2;
}

message ApiCancelFlowArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string flow_id = 2 [(sem_type) = {
      type: "ApiFlowId",
      description: "Flow id."
    }];
}

message ApiListFlowRequestsArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string flow_id = 2 [(sem_type) = {
      type: "ApiFlowId",
      description: "Flow id."
    }];
  optional int64 offset = 3 [(sem_type) = {
      description: "Results items starting offset."
    }];
  optional int64 count = 4 [(sem_type) = {
      description: "Max number of results to fetch."
    }];
}

message ApiListFlowRequestsResult {
  repeated ApiFlowRequest items = 1 [(sem_type) = {
      description: "Flow's requests list."
    }];
}

message ApiListFlowResultsArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string flow_id = 2 [(sem_type) = {
      type: "ApiFlowId",
      description: "Flow id."
    }];
  optional int64 offset = 3 [(sem_type) = {
      description: "Results items starting offset."
    }];
  optional int64 count = 4 [(sem_type) = {
      description: "Max number of results to fetch."
    }];
  optional string filter = 5 [(sem_type) = {
      description: "Return only results whose string representation "
      "contains given substring."
    }];
}

message ApiListFlowResultsResult {
  repeated ApiFlowResult items = 1 [(sem_type) = {
      description: "The flow results."
    }];
  optional int64 total_count = 2 [(sem_type) = {
      description: "Total count of items."
    }];
}

message ApiListFlowLogsArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string flow_id = 2 [(sem_type) = {
      type: "ApiFlowId",
      description: "Flow id."
    }];
  optional int64 offset = 3 [(sem_type) = {
      description: "Results items starting offset."
    }];
  optional int64 count = 4 [(sem_type) = {
      description: "Max number of results to fetch."
    }];
  optional string filter = 5 [(sem_type) = {
      description: "Return only results whose string representation "
      "contains given substring."
    }];
}

message ApiListFlowLogsResult {
  repeated FlowLog items = 1 [(sem_type) = {
      description: "The hunt errors"
    }];
   optional int64 total_count = 2 [(sem_type) = {
      description: "Total count of items."
   }];
};

message ApiGetFlowResultsExportCommandArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string flow_id = 2 [(sem_type) = {
      type: "ApiFlowId",
      description: "Flow id."
    }];
}

message ApiGetFlowResultsExportCommandResult {
  optional string command = 1 [(sem_type) = {
      description: "Export command for flow results."
    }];
}

message ApiListFlowOutputPluginsArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string flow_id = 2 [(sem_type) = {
      type: "ApiFlowId",
      description: "Flow id."
    }];
}

message ApiListFlowOutputPluginsResult {
  repeated ApiOutputPlugin items = 2;
}

message ApiListFlowOutputPluginLogsArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string flow_id = 2 [(sem_type) = {
      type: "ApiFlowId",
      description: "Flow id."
    }];
  optional string plugin_id = 3 [(sem_type) = {
      description: "Output plugin id."
    }];

  optional int64 offset = 4 [(sem_type) = {
      description: "Logs starting offset."
    }];
  optional int64 count = 5 [(sem_type) = {
      description: "Max number of log entries."
    }];
}

message ApiListFlowOutputPluginLogsResult {
  repeated OutputPluginBatchProcessingStatus items = 1 [(sem_type) = {
      description: "Log entries."
    }];

  optional int64 total_count = 2 [(sem_type) = {
    description: "Total count of items."
  }];
}


message ApiListFlowOutputPluginErrorsArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string flow_id = 2 [(sem_type) = {
      type: "ApiFlowId",
      description: "Flow id."
    }];
  optional string plugin_id = 3 [(sem_type) = {
      description: "Output plugin id."
    }];

  optional int64 offset = 4 [(sem_type) = {
      description: "Errors starting offset."
    }];
  optional int64 count = 5 [(sem_type) = {
      description: "Max number of errors."
    }];
}

message ApiListFlowOutputPluginErrorsResult {
  repeated OutputPluginBatchProcessingStatus items = 1 [(sem_type) = {
      description: "Errors entries."
    }];

  optional int64 total_count = 2 [(sem_type) = {
    description: "Total count of items."
  }];
}

message ApiGetFlowFilesArchiveArgs {
  enum ArchiveFormat {
    ZIP = 0;
    TAR_GZ = 1;
  }

  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string flow_id = 2 [(sem_type) = {
      description: "Flow id.",
      type: "ApiFlowId"
    }];
  optional ArchiveFormat archive_format = 3;
};

message ApiListFlowDescriptorsArgs {
  enum FlowType {
    CLIENT = 0;
    GLOBAL = 1;
  };
  optional FlowType flow_type = 1 [(sem_type) = {
      description: "If specified, narrows the list to the given type of flows "
      "only."
    }];
};

message ApiListFlowDescriptorsResult {
  repeated ApiFlowDescriptor items = 1;
}

message ApiListFlowsArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional int64 offset = 2 [(sem_type) = {
      description: "Starting offset."
    }];
  optional int64 count = 3 [(sem_type) = {
      description: "Max number of flows to fetch."
    }];
};

message ApiListFlowsResult {
  repeated ApiFlow items = 1;
};

message ApiAddClientsLabelsArgs {
  repeated string client_ids = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  repeated string labels = 2;
}

message ApiRemoveClientsLabelsArgs {
  repeated string client_ids = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  repeated string labels = 2;
}

message ApiListClientsLabelsResult {
  repeated AFF4ObjectLabel items = 1;
}

message ApiListKbFieldsResult {
  repeated string items = 2;
}

message ApiListHuntsArgs {
  optional int64 offset = 1 [(sem_type) = {
      description: "Starting offset."
    }];
  optional int64 count = 2 [(sem_type) = {
      description: "Max number of items to fetch."
    }];

  // Filtering criterias.
  optional string created_by = 3 [(sem_type) = {
      description: "Only return hunts created by a given user. "
      "If approved_by or/and description_contains are also supplied, "
      "then logical AND is applied to all the criterias. NOTE: this filter "
      "can only be used in conjunction with 'active_within' filter (to "
      "prevent queries of death)."
    }];
  optional string description_contains = 4 [(sem_type) = {
      description: "Only return hunts where description contains given "
      "substring (matching is case-insensitive)."
      "If created_by or/and approved_by are also supplied, "
      "then logical AND is applied to all the criterias. NOTE: this filter "
      "can only be used in conjunction with 'active_within' filter (to "
      "prevent queries of death)."
    }];
  optional uint64 active_within = 5 [(sem_type) = {
      type: "Duration",
      description: "Only return hunts that were active within given time "
      "duration."
    }];
}

message ApiListHuntsResult {
  repeated ApiHunt items = 1 [(sem_type) = {
      description: "List of hunts."
    }];
  optional int64 total_count = 2 [(sem_type) = {
      description: "Total number of items."
    }];
}

message ApiGetHuntArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
}

message ApiGetHuntClientCompletionStatsArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
  optional int64 size = 2 [(sem_type) = {
      description: "Max number of data points to fetch."
    }];
}

message ApiGetHuntClientCompletionStatsResult {
  repeated SampleFloat start_points = 1 [(sem_type) = {
      description: "The list of samples for client starts."
    }];
  repeated SampleFloat complete_points = 2 [(sem_type) = {
      description: "The list of samples for client completions."
    }];
}

message ApiListHuntLogsArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
  optional int64 offset = 2 [(sem_type) = {
      description: "Log items starting offset."
    }];
  optional int64 count = 3 [(sem_type) = {
      description: "Max number of log items to fetch."
    }];
  optional string filter = 4 [(sem_type) = {
      description: "Return only results whose string representation "
      "contains given substring."
    }];
};

message ApiListHuntLogsResult {
  repeated FlowLog items = 1 [(sem_type) = {
      description: "The hunt errors"
    }];
  optional int64 total_count = 2 [(sem_type) = {
      description: "Total count of items."
  }];
};

message ApiListHuntErrorsArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
  optional int64 offset = 2 [(sem_type) = {
      description: "Hunt errors starting offset."
    }];
  optional int64 count = 3 [(sem_type) = {
      description: "Max number of errors to fetch."
    }];
  optional string filter = 4 [(sem_type) = {
      description: "Return only results whose string representation "
      "contains given substring."
    }];
};

message ApiListHuntErrorsResult {
  repeated HuntError items = 1 [(sem_type) = {
      description: "The hunt errors"
    }];
  optional int64 total_count = 2 [(sem_type) = {
      description: "Total count of items."
  }];
};

message ApiListHuntCrashesArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
  optional int64 offset = 2 [(sem_type) = {
      description: "Hunt crashes starting offset."
    }];
  optional int64 count = 3 [(sem_type) = {
      description: "Max number of crashes to fetch."
    }];
  optional string filter = 4 [(sem_type) = {
      description: "Return only results whose string representation "
      "contains given substring."
    }];
};

message ApiListHuntCrashesResult {
  repeated ClientCrash items = 1 [(sem_type) = {
    description: "The client crashes"
  }];
  optional int64 total_count = 2 [(sem_type) = {
    description: "Total count of items."
  }];
};

message ApiListHuntResultsArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
  optional int64 offset = 2 [(sem_type) = {
      description: "Hunt results starting offset."
    }];
  optional int64 count = 3 [(sem_type) = {
      description: "Max number of results to fetch."
    }];
  optional string filter = 4 [(sem_type) = {
      description: "Return only results whose string representation "
      "contains given substring."
    }];
};

message ApiListHuntResultsResult {
  repeated ApiHuntResult items = 1 [(sem_type) = {
      description: "Hunt results."
    }];

  optional int64 total_count = 2 [(sem_type) = {
    description: "Total count of items."
  }];
}

message ApiGetHuntResultsExportCommandArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
};

message ApiGetHuntResultsExportCommandResult {
  optional string command = 1 [(sem_type) = {
      description: "Command that may be used to export hunt results."
    }];
}

message ApiListHuntOutputPluginsArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
};

message ApiListHuntOutputPluginsResult {
  repeated ApiOutputPlugin items = 1;

  optional int64 total_count = 2 [(sem_type) = {
    description: "Total count of items."
  }];
};


message ApiListHuntOutputPluginLogsArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
  optional string plugin_id = 2 [(sem_type) = {
      description: "Plugin id."
    }];

  optional int64 offset = 3 [(sem_type) = {
      description: "Status messages offset."
    }];
  optional int64 count = 4 [(sem_type) = {
      description: "Number of status messages to fetch."
    }];
};

message ApiListHuntOutputPluginLogsResult {
  repeated OutputPluginBatchProcessingStatus items = 1 [(sem_type) = {
      description: "Log entries."
    }];

  optional int64 total_count = 2 [(sem_type) = {
    description: "Total count of items."
  }];
}

message ApiListHuntOutputPluginErrorsArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
  optional string plugin_id = 2 [(sem_type) = {
      description: "Plugin id."
    }];

  optional int64 offset = 3 [(sem_type) = {
      description: "Errors offset."
    }];
  optional int64 count = 4 [(sem_type) = {
      description: "Number of errors messages to fetch."
    }];
};

message ApiListHuntOutputPluginErrorsResult {
  repeated OutputPluginBatchProcessingStatus items = 1 [(sem_type) = {
      description: "Errors entries."
    }];

  optional int64 total_count = 2 [(sem_type) = {
    description: "Total count of items."
  }];
}


message ApiGetHuntFilesArchiveArgs {
  enum ArchiveFormat {
    ZIP = 0;
    TAR_GZ = 1;
  }

  optional string hunt_id = 1 [(sem_type) = {
      description: "Hunt id.",
      type: "ApiHuntId"
    }];
  optional ArchiveFormat archive_format = 3;
};

message ApiGetHuntFileArgs {
  optional string hunt_id = 1 [(sem_type) = {
      description: "Hunt id.",
      type: "ApiHuntId"
    }];
  optional string client_id = 2 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional uint64 timestamp = 3 [(sem_type) = {
      type: "RDFDatetime",
      description: "Timestamp of the result in the collection."
    }];
  optional string vfs_path = 4 [(sem_type) = {
      description: "AFF4 path to the file to be downloaded",
    }];
}

message ApiGetHuntStatsArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
};

message ApiGetHuntStatsResult {
  optional ClientResourcesStats stats = 1 [(sem_type) = {
      description: "The stats."
    }];
};

message ApiListHuntClientsArgs {
  enum ClientStatus {
    STARTED = 0;
    OUTSTANDING = 1;
    COMPLETED = 2;
  }

  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
  optional int64 offset = 2 [(sem_type) = {
      description: "Starting offset."
    }];
  optional int64 count = 3 [(sem_type) = {
      description: "Max number of items to fetch."
    }];
  optional ClientStatus client_status = 4 [(sem_type) = {
      description: "The types of clients to fetch."
    }];
};

message ApiHuntClientPendingRequest {
  optional string flow_urn = 1 [(sem_type) = {
      type: "RDFURN",
      description: "The flow urn."
    }];
  optional string incomplete_request_id = 2 [(sem_type) = {
      description: "The id of the incomplete request."
    }];
  optional string next_state = 3 [(sem_type) = {
      description: "The next state of the flow."
    }];
  optional string expected_args = 4 [(sem_type) = {
      description: "The name of the expected arguments."
    }];
  optional int64 available_responses_count = 5 [(sem_type) = {
      description: "The number of available responses."
    }];
  optional string expected_responses = 6 [(sem_type) = {
      description: "The expected responses."
    }];
  optional bool is_status_available = 7 [(sem_type) = {
      description: "Whether the status is available or not."
    }];
  optional int64 available_client_requests_count = 8 [(sem_type) = {
      description: "The number of client requests available."
    }];
}

message ApiHuntClient {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "The client id."
    }];
  optional string flow_urn = 2 [(sem_type) = {
      type: "RDFURN",
      description: "The flow urn."
    }];
  optional CpuSeconds cpu_usage = 10 [(sem_type) = {
      description: "CPU usage (in seconds)."
    }];
  optional int64 network_bytes_sent = 11 [(sem_type) = {
      description: "Network usage (in bytes)."
    }];
  repeated ApiHuntClientPendingRequest pending_requests = 12;
};

message ApiListHuntClientsResult {
  repeated ApiHuntClient items = 1 [(sem_type) = {
      description: "The list of outstanding clients."
    }];
   optional int64 total_count = 2 [(sem_type) = {
      description: "Total count of items."
   }];
};

message ApiDataObject {
  repeated ApiDataObjectKeyValuePair items = 1 [(sem_type) = {
      description: "The items of the data object."
    }];
}

message ApiDataObjectKeyValuePair {
  optional string key = 1 [(sem_type) = {
      description: "The key."
    }];
  optional google.protobuf.Any value = 2 [(sem_type) = {
      description: "Flow arguments.",
      dynamic_type: "GetArgsClass"
    }];
  optional bool invalid = 3 [(sem_type) = {
      description: "Whether the value could be successfully serialized "
      "to the protobuf serialization format."
    }];
  optional string type = 4 [(sem_type) = {
      description: "The type of the value."
    }];
}

message ApiGetHuntContextArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
};

message ApiGetHuntContextResult {
  optional HuntContext context = 1 [(sem_type) = {
      description: "The hunt context."
    }];
  optional ApiDataObject state = 2 [(sem_type) = {
      description: "The hunt state."
    }];
};

// Next id: 6
message ApiCreateHuntArgs {
  optional string flow_name = 3 [(sem_type) = {
      description: "Cron flow name."
    }];
  optional google.protobuf.Any flow_args = 4 [(sem_type) = {
      description: "Cron flow arguments.",
      dynamic_type: "GetFlowArgsClass"
    }];
  optional HuntRunnerArgs hunt_runner_args = 1 [(sem_type) = {
      description: "Hunt runner arguments."
    }];
};

message ApiModifyHuntArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
  optional ApiHunt.State state = 2 [(sem_type) = {
      description: "Hunt state."
    }];
  optional int64 client_limit = 3 [(sem_type) = {
      description: "Client limit.",
    }];
  optional int64 client_rate = 4 [(sem_type) = {
      description: "Client rate.",
    }];
  optional uint64 expires = 5 [(sem_type) = {
      type: "RDFDatetime",
      description: "When the hunt should expire."
    }];
}

message ApiDeleteHuntArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
}

message ApiGetRDFValueDescriptorArgs {
  optional string type = 1 [(sem_type) = {
      description: "RDFValue type name."
    }];
}

message ApiListRDFValueDescriptorsResult {
  repeated ApiRDFValueDescriptor items = 1;
};

message ApiAff4AttributeDescriptor {
  optional string name = 1;
}

message ApiListAff4AttributeDescriptorsResult {
  repeated ApiAff4AttributeDescriptor items = 1;
}

message ApiListStatsStoreMetricsMetadataArgs {
  enum Component {
    WORKER = 0;
    FRONTEND = 1;
    ADMIN_UI = 2;
  }
  optional Component component = 1;
}

message ApiListStatsStoreMetricsMetadataResult {
  repeated MetricMetadata items = 1;
}

message ApiListCronJobsArgs {
  optional int64 offset = 1 [(sem_type) = {
      description: "Starting offset."
    }];
  optional int64 count = 2 [(sem_type) = {
      description: "Max number of cron jobs to fetch."
    }];
};

message ApiListCronJobsResult {
  repeated ApiCronJob items = 1 [(sem_type) = {
      description: "Cron jobs."
    }];
   optional int64 total_count = 2 [(sem_type) = {
      description: "Total count of items."
   }];
}

message ApiGetCronJobArgs {
  optional string cron_job_id = 1 [(sem_type) = {
      description: "Cron job id."
    }];
}

message ApiForceRunCronJobArgs {
  optional string cron_job_id = 1 [(sem_type) = {
      description: "Cron job id."
    }];
}

message ApiModifyCronJobArgs {
  optional string cron_job_id = 1 [(sem_type) = {
      description: "Cron job id."
    }];
  optional ApiCronJob.State state = 2 [(sem_type) = {
      description: "New cron job state value."
    }];
}

message ApiListCronJobFlowsArgs {
  optional string cron_job_id = 1 [(sem_type) = {
      description: "Cron job id."
    }];
  optional int64 offset = 2 [(sem_type) = {
      description: "Starting offset."
    }];
  optional int64 count = 3 [(sem_type) = {
      description: "Max number of flows to fetch."
    }];
};

message ApiGetCronJobFlowArgs {
  optional string cron_job_id = 1 [(sem_type) = {
      description: "Cron job id."
    }];
  optional string flow_id = 2 [(sem_type) = {
      type: "ApiFlowId",
      description: "Flow id."
    }];
}

message ApiDeleteCronJobArgs {
  optional string cron_job_id = 1 [(sem_type) = {
      description: "The id of the cron job."
    }];
};

// Next field number: 8
message ApiGetStatsStoreMetricArgs {
  enum Component {
    WORKER = 0;
    FRONTEND = 1;
    ADMIN_UI = 2;
  }
  optional Component component = 1;
  optional string metric_name = 2;

  optional uint64 start = 3 [(sem_type) = {
      type: "RDFDatetime",
      description: "Fetch metrics data starting from this timestamp. If "
      "not set, will default to 1 hour ago."
    }];
  optional uint64 end = 4 [(sem_type) = {
      type: "RDFDatetime",
      description: "Fetch metrics data from the interval ending with "
      "this timestamp. If not set, will default to the current time."
    }];

  optional uint64 rate = 7 [(sem_type) = {
      type: "Duration",
      description: "If set, metric's rate over given window will be returned "
      "instead of plain values."
    }];

  enum DistributionHandlingMode {
    DH_SUM = 0 [(description) = "Sum of all values recorded in a distribution "
             "will be fetched."];
    DH_COUNT = 1 [(description) = "Number of all values recorded in a distribution "
               "will be fetched."];
  };
  optional DistributionHandlingMode distribution_handling_mode = 5 [(sem_type) = {
      description: "Determines which values to fetch when dealing with distributions."
    }];

  enum AggregationMode {
    AGG_SUM = 0 [(description) = "Values will be summed."];
    AGG_MEAN = 1 [(description) = "Mean value will be calculated."];
    AGG_NONE = 2 [(description) = "No aggregation will be performed."];
  };
  optional AggregationMode aggregation_mode = 6 [(sem_type) = {
      description: "Aggregation method. As metrics are usually collected across "
        "multiple processes, most of the time they have to be aggregated."
    }];
}

message ApiStatsStoreMetricDataPoint {
  optional uint64 timestamp = 1 [(sem_type) = {
      type: "RDFDatetime",
      description: "Timestamp of the data point."
    }];
  optional double value = 2 [(sem_type) = {
      description: "Value corresponding to the timestamp."
    }];
}

message ApiStatsStoreMetric {
  optional string metric_name = 1;
  optional uint64 start = 2 [(sem_type) = {
      type: "RDFDatetime",
    }];
  optional uint64 end = 3 [(sem_type) = {
      type: "RDFDatetime",
    }];
  repeated ApiStatsStoreMetricDataPoint data_points = 4;
}

message ApiReportDescriptor {
  enum ReportType {
    CLIENT = 0 [(description) = "Client"];
    FILE_STORE = 1 [(description) = "File store"];
    SERVER = 2 [(description) = "Server"];
  }

  optional ReportType type = 1 [(sem_type) = {
      description: "Top-level identifier in the report hierarchy."
    }];

  optional string name = 2 [(sem_type) = {
      description: "Second-level identifier in the report hierarchy. "
        "Also the name of the corresponding class in report_plugins.py. "
        "Eg 'ClientsActivityReportPlugin'."
    }];

  optional string title = 3 [(sem_type) = {
      description: "UI-friendly displayed title."
    }];

  optional string summary = 4 [(sem_type) = {
      description: "UI-friendly displayed summary of what the report reports."
    }];

  optional bool requires_time_range = 5 [(sem_type) = {
      description: "Indicates whether the report needs a time range."
    }];
}

message ApiReport {
  optional ApiReportDescriptor desc = 1;
  optional ApiReportData data = 2;
}

message ApiGetReportArgs {
  optional string name = 1 [(sem_type) = {
      description: "Identifier in the report hierarchy. Also the name of the "
        "corresponding class in report_plugins.py. "
        "Eg 'ClientsActivityReportPlugin'."
    }];

  optional uint64 start_time = 2 [(sem_type) = {
      type: "RDFDatetime",
      description: "Earliest timestamp of data points to consider. "
        "Ignored by reports with requires_time_range set to false."
    }];

  optional uint64 duration = 3 [(sem_type) = {
      type: "Duration",
      description: "Length of the time range to consider. "
        "Ignored by reports with requires_time_range set to false."
    }];

  optional string client_label = 4 [(sem_type) = {
      description: "Client label used by label-specific reports. Optional."
    }];
}

message ApiReportData {
  option (semantic) = {
    union_field: "representation_type"
  };

  enum RepresentationType {
    STACK_CHART = 0 [(description) = "Stack chart"];
    PIE_CHART = 1 [(description) = "Pie chart"];
    LINE_CHART = 2 [(description) = "Line chart"];
    AUDIT_CHART = 3 [(description) = "Audit chart"];
  }

  optional RepresentationType representation_type = 1;

  optional ApiStackChartReportData stack_chart = 2;
  optional ApiPieChartReportData pie_chart = 3;
  optional ApiLineChartReportData line_chart = 4;
  optional ApiAuditChartReportData audit_chart = 5;
}

message ApiStackChartReportData {
  repeated ApiReportDataSeries2D data = 1 [(sem_type) = {
      description: "What the report contains."
    }];

  repeated ApiReportTickSpecifier x_ticks = 2 [(sem_type) = {
      description: "X axis ticks. See: github.com/flot/flot/blob/master/API.md"
    }];

  repeated ApiReportTickSpecifier y_ticks = 3 [(sem_type) = {
      description: "Y axis ticks. See: github.com/flot/flot/blob/master/API.md"
    }];

  optional float bar_width = 4 [(sem_type) = {
      description: "Width of the bars displayed on the chart."
    }];
}

message ApiPieChartReportData {
  repeated ApiReportDataPoint1D data = 1 [(sem_type) = {
      description: "What the report contains."
    }];
}

message ApiLineChartReportData {
  repeated ApiReportDataSeries2D data = 1 [(sem_type) = {
      description: "What the report contains."
    }];
}

message ApiAuditChartReportData {
  repeated string used_fields = 1 [(sem_type) = {
      description: "Names of the AuditEvent fields used by the report."
    }];

  repeated AuditEvent rows = 2 [(sem_type) = {
      description: "Data to be shown in the chart."
    }];
}

message ApiReportDataPoint1D {
  optional float x = 1;

  optional string label = 2 [(sem_type) = {
      description: "The series is labeled with this string."
    }];
}

message ApiReportDataSeries2D {
  optional string label = 1 [(sem_type) = {
      description: "The series is labeled with this string."
    }];

  repeated ApiReportDataPoint2D points = 2;
}

message ApiReportDataPoint2D {
  optional float x = 1;
  optional float y = 2;
}

message ApiReportTickSpecifier {
  optional float x = 1;
  optional string label = 2;
}

message ApiListReportsResult {
  repeated ApiReport reports = 1 [(sem_type) = {
      description: "The report list."
    }];
}

message ApiListArtifactsArgs {
  optional int64 offset = 1 [(sem_type) = {
      description: "Starting offset."
    }];
  optional int64 count = 2 [(sem_type) = {
      description: "Max number of items to fetch."
    }];
}

message ApiListArtifactsResult {
  repeated ArtifactDescriptor items = 1 [(sem_type) = {
      description: "The flow results."
    }];
   optional int64 total_count = 2 [(sem_type) = {
      description: "Total count of items."
   }];
};

message ApiUploadArtifactArgs {
  optional bytes artifact = 1 [(sem_type) = {
      description: "Artifact YAML definition."
    }];
}

message ApiDeleteArtifactsArgs {
  repeated string names = 1 [(sem_type) = {
      description: "Names of the artifacts to be deleted."
    }];
}

message ApiGetConfigResult {
  repeated ApiConfigSection sections = 1;
}

message ApiGetConfigOptionArgs {
  optional string name = 1 [(sem_type) = {
      description: "Name of the config option to fetch."
    }];
}

message ApiCreateHuntApprovalArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
  optional ApiHuntApproval approval = 2;
}

message ApiGetHuntApprovalArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
  optional string approval_id = 2 [(sem_type) = {
      description: "Hunt approvals are uniquely identified by the user who "
      "requested them, the hunt id in question, and the approval id."
    }];
  optional string username = 3 [(sem_type) = {
      description: "Username of the user, whose hunt approval is being "
      "requested."
    }];
}

message ApiGrantHuntApprovalArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
  optional string approval_id = 2 [(sem_type) = {
      description: "Hunt approvals are uniquely identified by the user who "
      "requested them, the hunt id in question, and the approval id."
    }];
  optional string username = 3 [(sem_type) = {
      description: "Username of the user, whose hunt approval is being "
      "requested."
    }];
}

message ApiListHuntApprovalsArgs {
  optional int64 offset = 1 [(sem_type) = {
      description: "Approvals starting offset."
    }];
  optional int64 count = 2 [(sem_type) = {
      description: "Number of approvals to fetch."
    }];
}

message ApiListHuntApprovalsResult {
  repeated ApiHuntApproval items = 1;
}

message ApiCreateCronJobApprovalArgs {
  optional string cron_job_id = 1 [(sem_type) = {
      description: "Cron id."
    }];
  optional ApiCronJobApproval approval = 2;
}

message ApiGetCronJobApprovalArgs {
  optional string cron_job_id = 1 [(sem_type) = {
      description: "Cron id."
    }];
  optional string approval_id = 2 [(sem_type) = {
      description: "Cron job approvals are uniquely identified by the user who "
      "requested them, the cron id in question, and the approval id."
    }];
  optional string username = 3 [(sem_type) = {
      description: "Username of the user, whose cron approval is being "
      "requested."
    }];
}

message ApiGrantCronJobApprovalArgs {
  optional string cron_job_id = 1 [(sem_type) = {
      description: "Cron id."
    }];
  optional string approval_id = 2 [(sem_type) = {
      description: "Cron job approvals are uniquely identified by the user who "
      "requested them, the cron id in question, and the approval id."
    }];
  optional string username = 3 [(sem_type) = {
      description: "Username of the user, whose cron approval is being "
      "requested."
    }];
}

message ApiListCronJobApprovalsArgs {
  optional int64 offset = 1 [(sem_type) = {
      description: "Approvals starting offset."
    }];
  optional int64 count = 2 [(sem_type) = {
      description: "Number of approvals to fetch."
    }];
}

message ApiListCronJobApprovalsResult {
  repeated ApiCronJobApproval items = 1;
}

message ApiCreateClientApprovalArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional ApiClientApproval approval = 2;
  optional bool keep_client_alive = 3 [(sem_type) = {
      description: "If true, the client will be kept alive for an hour right "
      "after the approval request is sent."
    }];
}

message ApiGetClientApprovalArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string approval_id = 2 [(sem_type) = {
      description: "Client approvals are uniquely identified by the user who "
      "requested them, the client id in question, and the approval id."
    }];
  optional string username = 3 [(sem_type) = {
      description: "Username of the user, whose client approval is being "
      "requested."
    }];
};

message ApiGrantClientApprovalArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string approval_id = 2 [(sem_type) = {
      description: "Client approvals are uniquely identified by the user who "
      "requested them, the client id in question, and the approval id."
    }];
  optional string username = 3 [(sem_type) = {
      description: "Username of the user, whose client approval is being "
      "requested."
    }];
};

message ApiListClientApprovalsArgs {
  enum State {
    ANY = 0;
    VALID = 1;
    INVALID = 2;
  };

  optional int64 offset = 1 [(sem_type) = {
      description: "Approvals starting offset."
    }];
  optional int64 count = 2 [(sem_type) = {
      description: "Number of approvals to fetch."
    }];
  optional string client_id = 3 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional State state = 4 [(sem_type) = {
      description: "The state of approvals to fetch."
    }];
}

message ApiListClientApprovalsResult {
  repeated ApiClientApproval items = 1;
}

message ApiListOutputPluginDescriptorsResult {
  repeated ApiOutputPluginDescriptor items = 1;
}

message ApiStartRobotGetFilesOperationArgs {
  optional string hostname = 1 [(sem_type) = {
      description: "Target host. Can be FQDN or client ID."
    }];
  repeated string paths = 2 [(sem_type) = {
      type: "GlobExpression",
      description: "Fetch this number of elements."
    }];
  optional uint64 max_file_size = 3 [(sem_type) = {
      type: "ByteSize",
      description: "Maximum size of file we will download.",
    }, default=20000000]; // 20MB
  optional FileFinderAction.Action action = 4 [(sem_type) = {
      description: "Action to apply to found files"
    }, default=DOWNLOAD];
  optional PathSpec.PathType pathtype = 5 [(sem_type) = {
      description: "Path type to glob in.",
    }, default=OS];
}

message ApiStartRobotGetFilesOperationResult {
  optional string operation_id = 1 [(sem_type) = {
      description: "The id of the 'get files' operation."
    }];
}

message ApiGetRobotGetFilesOperationStateArgs {
  optional string operation_id = 1 [(sem_type) = {
      description: "The id of the 'get files' operation."
    }];
}

message ApiGetRobotGetFilesOperationStateResult {
  optional ApiFlow.State state = 1 [(sem_type) = {
      description: "The state of the 'get files' operation."
    }];
  optional uint64 result_count = 2 [(sem_type) = {
      description: "Number of files found and downloaded."
    }];
};


//
// AFF4 object renderers arguments (see gui/api_aff4_object_renderers.py).
//
message ApiAFF4ObjectRendererArgs {
  optional int64 limit_lists = 1 [(sem_type) = {
      description: "If >0, lists of values in the response will contain "
      "no more than specified number of items. This is an effective way to "
      "protect the UI from fetching and presenting enormously big datasets. "
      "If 0, no lists will be rendered at all. If -1, lists will be rendered "
      "in their entirety."
    }, default = -1];
}

message ApiGRRHuntRendererArgs {
  optional bool with_full_summary = 1 [(sem_type) = {
      description: "If True, render stats, clients counts, rules and args."
    }];
}

message ApiRDFValueCollectionRendererArgs {
  optional int64 offset = 1 [(sem_type) = {
      description: "Fetch items starting from this offset."
    }];
  optional int64 count = 2 [(sem_type) = {
      description: "Fetch this number of elements."
    }];
  optional bool with_total_count = 3 [(sem_type) = {
      description: "Include total number of elements in the collection into the"
        " response. NOTE: for some collections this may be expensive."
    }];
  optional string filter = 4 [(sem_type) = {
      description: "Return only collection items whose string representation "
      "contains given substring."
    }];

  optional int64 items_limit_lists = 5 [(sem_type) = {
      description: "If >0, lists of values in the response will contain "
      "no more than specified number of items. This is an effective way to "
      "protect the UI from fetching and presenting enormously big datasets. "
      "If 0, no lists will be rendered at all. If -1, lists will be rendered "
      "in their entirety."
    }, default = -1];
}


// API entities. These are used in API calls responses.

// These traits are used by the AdminUI Angular app to disable certain UI
// elements.
message ApiGrrUserInterfaceTraits {
  optional bool cron_jobs_nav_item_enabled = 1;
  optional bool create_cron_job_action_enabled = 2;

  optional bool hunt_manager_nav_item_enabled = 3;
  optional bool create_hunt_action_enabled = 4;

  optional bool show_statistics_nav_item_enabled = 5;

  optional bool start_global_flows_nav_item_enabled = 6;

  optional bool server_load_nav_item_enabled = 7;

  optional bool manage_binaries_nav_item_enabled = 9;
  optional bool upload_binary_action_enabled = 10;

  optional bool settings_nav_item_enabled = 11;

  optional bool artifact_manager_nav_item_enabled = 12;
  optional bool upload_artifact_action_enabled = 13;

  optional bool search_clients_action_enabled = 14;
  optional bool browse_virtual_file_system_nav_item_enabled = 15;
  optional bool start_client_flow_nav_item_enabled = 16;
  optional bool manage_client_flows_nav_item_enabled = 17;
  optional bool modify_client_labels_action_enabled = 18;
};

message ApiGrrUser {
  optional string username = 1 [(sem_type) = {
      description: "The name of the user."
    }];
  optional GUISettings settings = 2 [(sem_type) = {
      description: "User UI settings."
    }];
  optional ApiGrrUserInterfaceTraits interface_traits = 3 [(sem_type) = {
      description: "User's interface traits (what they can and can't do "
      "in the UI)."
    }];
}

message ApiConfigOption {
  optional string name = 1;
  optional bool is_redacted = 2;

  optional google.protobuf.Any value = 3 [(sem_type) = {
      description: "Config option value.",
      dynamic_type: "GetValueClass"
    }];
  optional string type = 4 [(sem_type) = {
      description: "The type of the value."
    }];
  optional bool is_invalid = 5 [(sem_type) = {
      description: "Whether the value could be successfully serialized "
      "to the protobuf serialization format."
    }];
}

message ApiConfigSection {
  optional string name = 1;
  repeated ApiConfigOption options = 2;
}

message ApiFlowDescriptor {
  optional string name = 1 [(sem_type) = {
      description: "Flow name as registered in GRR."
    }];
  optional string friendly_name = 2 [(sem_type) = {
      description: "Friendly flow name."
    }];
  optional string category = 3 [(sem_type) = {
      description: "Flow category."
    }];
  optional string doc = 4 [(sem_type) = {
      description: "Flow documentation string."
    }];

  optional string args_type = 5 [(sem_type) = {
      description: "Flow arguments type name."
    }];
  optional google.protobuf.Any default_args = 6 [(sem_type) = {
      description: "Default flow arguments.",
      dynamic_type: "GetDefaultArgsClass"
    }];

  repeated string behaviours = 7 [(sem_type) = {
      description: "Flow behaviours."
    }];
}


message ApiRDFAllowedEnumValueDescriptor {
  optional string name = 1 [(sem_type) = {
      description: "Enum value name."
    }];
  optional int64 value = 2 [(sem_type) = {
      description: "Enum value value."
    }];
  optional string doc = 3 [(sem_type) = {
      description: "Documentation string."
    }];
  repeated string labels = 4 [(sem_type) = {
      description: "List of labels applied to this value."
    }];
}

message ApiRDFValueFieldDescriptor {
  optional string name = 1 [(sem_type) = {
      description: "Field name."
    }];
  optional string type = 2 [(sem_type) = {
      description: "Field type (an RDFValue type name)."
    }];
  optional uint32 index = 3 [(sem_type) = {
      description: "Field index."
    }];
  optional bool repeated = 4 [(sem_type) = {
      description: "If the field is repeated or not."
    }];
  optional bool dynamic = 5 [(sem_type) = {
      description: "If the field has a dynamically changing type or not."
    }];

  optional string doc = 6 [(sem_type) = {
      description: "Documentation string."
    }];
  optional string friendly_name = 7 [(sem_type) = {
      description: "Friendly name of the field to be shown in the UI."
    }];
  optional string context_help_url = 8 [(sem_type) = {
      description: "Context help URL to be shown in the UI."
    }];

  optional google.protobuf.Any default = 9 [(sem_type) = {
      dynamic_type: "GetDefaultValueClass",
      description: "Recommended default value."
    }];
  repeated string labels = 10 [(sem_type) = {
      description: "List of labels applied to this field."
    }];

  repeated ApiRDFAllowedEnumValueDescriptor allowed_values = 11 [(sem_type) = {
      description: "Allowed enum values. Applicable only to enum fields. If "
      "this list is not empty, then this descriptor describes an enum field."
    }];
}

message ApiRDFValueDescriptor {
  enum Kind {
    PRIMITIVE = 0;
    STRUCT = 1;
  }

  optional string name = 1 [(sem_type) = {
      description: "Type name."
    }];
  optional string doc = 2 [(sem_type) = {
      description: "Human-readable description of this type."
    }];
  optional Kind kind = 3 [(sem_type) = {
      description: "Indicates whether the value is a primitive value, or a "
      "structure."
    }];
  optional google.protobuf.Any default = 4 [(sem_type) = {
      dynamic_type: "GetDefaultValueClass",
      description: "Recommended default value."
    }];
  repeated string parents = 5 [(sem_type) = {
      description: "Inheritance chain of this type."
    }];
  repeated ApiRDFValueFieldDescriptor fields = 6 [(sem_type) = {
      description: "Descriptors of all the fields of this type. Only "
      "applicable to types with kind=STRUCT."
    }];
  optional string union_field_name = 7 [(sem_type) = {
      description: "If this structure is a union, union_field identifies the "
      "field that determines which part of the union is used."
    }];
}

message ApiHuntApproval {
  optional ApiHunt subject = 1 [(sem_type) = {
      description: "A hunt that has to be accessed after this approval "
      "is granted."
    }];

  optional string id = 8 [(sem_type) = {
      description: "Approval id. Approval is identified by the hunt id, "
      "requestor's username and the approval id."
    }];

  optional string reason = 2 [(sem_type) = {
      description: "A reason for accessing the hunt."
    }];
  optional bool is_valid = 3 [(sem_type) = {
      description: "If True, this approval is still valid. If False, then "
      "it wasn't approved or got expired."
    }];
  optional string is_valid_message = 4 [(sem_type) = {
      description: "If is_valid is False, is_valid_message will contain "
      "a human-readable description of why the approval is not valid."
    }];

  repeated string notified_users = 5 [(sem_type) = {
      description: "GRR users that will be notified about the approval "
      "being requested."
    }];
  repeated string email_cc_addresses = 6 [(sem_type) = {
      description: "List of emails used to send a notification to about "
      "this approval being requested."
  }];

  repeated string approvers = 7 [(sem_type) = {
      description: "List of GRR users who granted this approval. Note: this "
      "list always includes the original approval requestor."
    }];
}

message ApiCronJobApproval {
  optional ApiCronJob subject = 1 [(sem_type) = {
      description: "A cron job that has to be accessed after this approval "
      "is granted."
    }];

  optional string id = 8 [(sem_type) = {
      description: "Approval id. Approval is identified by the cron job id, "
      "requestor's username and the approval id."
    }];

  optional string reason = 2 [(sem_type) = {
      description: "A reason for accessing the cron job."
    }];
  optional bool is_valid = 3 [(sem_type) = {
      description: "If True, this approval is still valid. If False, then "
      "it wasn't approved or got expired."
    }];
  optional string is_valid_message = 4 [(sem_type) = {
      description: "If is_valid is False, is_valid_message will contain "
      "a human-readable description of why the approval is not valid."
    }];

  repeated string notified_users = 5 [(sem_type) = {
      description: "GRR users that will be notified about the approval "
      "being requested."
    }];
  repeated string email_cc_addresses = 6 [(sem_type) = {
      description: "List of emails used to send a notification to about "
      "this approval being requested."
  }];

  repeated string approvers = 7 [(sem_type) = {
      description: "List of GRR users who granted this approval. Note: this "
      "list always includes the original approval requestor."
    }];
}

message ApiClientApproval {
  optional ApiClient subject = 1 [(sem_type) = {
      description: "A client that has to be accessed after this approval "
      "is granted."
    }];

  optional string id = 8 [(sem_type) = {
      description: "Approval id. Approval is identified by the client id, "
      "requestor's username and the approval id."
    }];

  optional string reason = 2 [(sem_type) = {
      description: "A reason for accessing the client."
    }];
  optional bool is_valid = 3 [(sem_type) = {
      description: "If True, this approval is still valid. If False, then "
      "it wasn't approved or got expired."
    }];
  optional string is_valid_message = 4 [(sem_type) = {
      description: "If is_valid is False, is_valid_message will contain "
      "a human-readable description of why the approval is not valid."
    }];

  repeated string notified_users = 5 [(sem_type) = {
      description: "GRR users that will be notified about the approval "
      "being requested."
    }];
  repeated string email_cc_addresses = 6 [(sem_type) = {
      description: "List of emails used to send a notification to about "
      "this approval being requested."
  }];

  repeated string approvers = 7 [(sem_type) = {
      description: "List of GRR users who granted this approval. Note: this "
      "list always includes the original approval requestor."
    }];
}

// Next id: 20
message ApiClient {
  optional string client_id = 18 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];

  optional string urn = 1 [(sem_type) = {
      type: "ClientURN",
      description: "Client URN."
    }];

  optional ClientInformation agent_info = 2;
  optional HardwareInfo hardware_info = 3;
  optional Uname os_info = 4;
  optional KnowledgeBase knowledge_base = 16;
  optional uint64 memory_size = 17 [(sem_type) = {
      type: "ByteSize",
      description: "Memory available to this client."
    }];

  optional uint64 first_seen_at = 6 [(sem_type) = {
      type: "RDFDatetime",
      description: "When flow was created."
    }];
  optional uint64 last_seen_at = 7 [(sem_type) = {
      type: "RDFDatetime",
      description: "Last time when client checked in."
    }];
  optional uint64 last_booted_at = 8 [(sem_type) = {
      type: "RDFDatetime",
      description: "Last boot time."
    }];
  optional uint64 last_clock = 9 [(sem_type) = {
      type: "RDFDatetime",
      description: "Client clocks value during latest checkin."
    }];
  optional uint64 last_crash_at = 10 [(sem_type) = {
      type: "RDFDatetime",
      description: "Last crash time."
    }];

  repeated AFF4ObjectLabel labels = 11;
  repeated Interface interfaces = 12;
  repeated User users = 13;
  repeated Volume volumes = 14;

  optional uint64 age = 15 [(sem_type) = {
      type: "RDFDatetime",
      description: "Age of the client information."
    }];
  optional CloudInstance cloud_instance = 19;
}


// Next id: 13
message ApiFlow {
  // Enum values here correspond to Flow.State values.
  enum State {
    RUNNING = 0;
    TERMINATED = 1;
    ERROR = 3;
    CLIENT_CRASHED = 4;
  };

  optional string urn = 1 [(sem_type) = {
      type: "SessionID",
      description: "Flow URN."
    }];
  optional string flow_id = 12 [(sem_type) = {
      type: "ApiFlowId",
      description: "Flow id."
    }];

  optional string name = 2 [(sem_type) = {
      description: "Flow name.",
    }];
  optional google.protobuf.Any args = 3 [(sem_type) = {
      description: "Flow arguments.",
      dynamic_type: "GetArgsClass"
    }];
  optional FlowRunnerArgs runner_args = 4 [(sem_type) = {
      description: "Flow runner arguments."
    }];
  optional State state = 5 [(sem_type) = {
      description: "Current flow state."
    }];
  optional uint64 started_at = 6 [(sem_type) = {
      type: "RDFDatetime",
      description: "When flow was created."
    }];
  optional uint64 last_active_at = 7 [(sem_type) = {
      type: "RDFDatetime",
      description: "When flow was last active."
    }];
  optional string creator = 8 [(sem_type) = {
      description: "Who started the flow."
    }];

  optional ApiDataObject state_data = 10 [(sem_type) = {
      description: "Current flow state data."
    }];
  optional FlowContext context = 11 [(sem_type) = {
      description: "Current flow context."
    }];

  repeated ApiFlow nested_flows = 9 [(sem_type) = {
      description: "Nested flows started by this flow."
    }];
}

message ApiFlowRequest {
  optional string request_id = 1;
  optional RequestState request_state = 2;
  repeated GrrMessage responses = 3;
}

message ApiFlowResult {
  optional google.protobuf.Any payload = 1 [(sem_type) = {
      description: "Result payload.",
      dynamic_type: "GetPayloadClass"
    }];
  optional string payload_type = 2 [(sem_type) = {
      description: "Type of the payload."
    }];
  optional uint64 timestamp = 3 [(sem_type) = {
      type: "RDFDatetime",
      description: "Timestamp indicating when result was written to the data "
      "store."
    }];
}

// Next id: 22
message ApiHunt {
  // Enum values here correspond to Hunt.State values.
  enum State {
    PAUSED = 0;
    STARTED = 1;
    STOPPED = 2;
    COMPLETED = 3;
  };

  optional string urn = 1 [(sem_type) = {
      type: "SessionID",
      description: "Hunt URN."
    }];
  optional string name = 2 [(sem_type) = {
      description: "Hunt name.",
    }];
  optional State state = 4 [(sem_type) = {
      description: "Current hunt state."
    }];

  optional string flow_name = 20 [(sem_type) = {
      description: "Cron flow name."
    }];
  optional google.protobuf.Any flow_args = 21 [(sem_type) = {
      description: "Cron flow arguments.",
      dynamic_type: "GetFlowArgsClass"
    }];
  optional HuntRunnerArgs hunt_runner_args = 6 [(sem_type) = {
      description: "Hunt runner arguments."
    }];

  optional int64 all_clients_count = 7 [(sem_type) = {
      description: "Count of all clients.",
    }];
  optional int64 remaining_clients_count = 8 [(sem_type) = {
      description: "Count of remaining clients.",
    }];
  optional int64 completed_clients_count = 9 [(sem_type) = {
      description: "Count of completed clients.",
    }];
  optional int64 client_limit = 10 [(sem_type) = {
      description: "Client limit.",
    }];
  optional float client_rate = 11 [(sem_type) = {
      description: "Client rate.",
    }];
  optional uint64 created = 12 [(sem_type) = {
      type: "RDFDatetime",
      description: "Creation time of the hunt."
    }];
  optional uint64 expires = 13 [(sem_type) = {
      type: "RDFDatetime",
      description: "Expiration time of the hunt."
    }];
  optional string creator = 14 [(sem_type) = {
      description: "Name of the user who created the hunt."
    }];
  optional string description = 15 [(sem_type) = {
      description: "Hunt description."
    }];
  optional ForemanClientRuleSet client_rule_set = 16 [(sem_type) = {
       description: "Client rules."
    }];
  optional bool is_robot = 17 [(sem_type) = {
      description: "Whether the hunt was created by a GRRWorker."
    }];
  optional float total_cpu_usage = 18 [(sem_type) = {
      description: "Total CPU usage (in seconds)."
    }];
  optional int64 total_net_usage = 19 [(sem_type) = {
      description: "Total network usage (in bytes)."
    }];
}

message ApiHuntResult {
  optional string client_id = 2 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional google.protobuf.Any payload = 3 [(sem_type) = {
      description: "Result payload.",
      dynamic_type: "GetPayloadClass"
    }];
  optional string payload_type = 4 [(sem_type) = {
      description: "Type of the payload."
    }];
  optional uint64 timestamp = 5 [(sem_type) = {
      type: "RDFDatetime",
      description: "Timestamp indicating when result was written to the data "
      "store."
    }];
}

// Next id: 13
message ApiCronJob {
  enum State {
    ENABLED = 0;
    DISABLED = 1;
  };

  optional string urn = 1 [(sem_type) = {
      type: "RDFURN",
      description: "Cron job URN."
    }];
  optional string description = 2 [(sem_type) = {
      description: "Cron job description."
    }];
  optional string flow_name = 3 [(sem_type) = {
      description: "Cron flow name."
    }];
  optional google.protobuf.Any flow_args = 4 [(sem_type) = {
      description: "Cron flow arguments.",
      dynamic_type: "GetArgsClass"
    }];
  optional FlowRunnerArgs flow_runner_args = 5 [(sem_type) = {
      description: "Flow runner arguments."
    }];
  optional uint64 periodicity = 6 [(sem_type) = {
      type: "Duration",
      description: "Interval between cron runs."
    }];
  optional uint64 lifetime = 7 [(sem_type) = {
      type: "Duration",
      description: "How long each run of the cron should be allowed to run. "
      "Runs that exceed lifetime will be killed. This is complimentary but"
      " different to periodicity e.g. it allows us to run jobs weekly that"
      " should be killed if they take more than a few hours.",
    }];
  optional bool allow_overruns = 8 [(sem_type) = {
      description: "If true, don't kill the previous run if new one starts.",
      label: ADVANCED
    }];

  optional State state = 9 [(sem_type) = {
      description: "Current flow state."
    }];
  optional uint64 last_run_time = 10 [(sem_type) = {
      type: "RDFDatetime",
      description: "Last time when this cron job ran."
    }];
  optional bool is_failing = 11 [(sem_type) = {
      description: "Is this cron job constantly failing?"
    }];
}

// Next id: 6
message ApiOutputPluginDescriptor {
  enum PluginType {
    LEGACY = 0;
    INSTANT = 1;
    LIVE = 2;
  }

  optional PluginType plugin_type = 4;

  optional string name = 1 [(sem_type) = {
      description: "Output plugin's name."
    }];
  optional string friendly_name = 5 [(sem_type) = {
      description: "Human readable output plugin's description."
    }];
  optional string description = 2 [(sem_type) = {
      description: "Human readable output plugin's description."
    }];
  optional string args_type = 3 [(sem_type) = {
      description: "RDF type of the arguments that output plugin takes."
    }];
}

message ApiOutputPlugin {
  optional string id = 1 [(sem_type) = {
      description: "String identifying the output plugin."
    }];
  optional OutputPluginDescriptor plugin_descriptor = 2 [(sem_type) = {
      description: "Descriptor of the output plugin."
    }];
  optional google.protobuf.Any state = 3 [(sem_type) = {
      description: "State of the plugin.",
      dynamic_type: "GetStateClass"
    }];
  optional OutputPluginVerificationResult last_verification_result = 4 [(sem_type) = {
      description: "Results of the last verification check done on the output "
      "of this plugin. Verification checks check that expected output exists "
      "and that it's complete. Not all output plugins support verification. "
      "For example CSV and Email plugins output can't be verified. On the "
      "other hand, BigQuery output can be verified, as BigQuery service can "
      "be queried for the results that were supposed to be uploaded."
    }];
}

// Next id: 12
message ApiFile {
  optional string name = 1 [(sem_type) = {
      description: "File name."
    }];
  optional string path = 2 [(sem_type) = {
      description: "File path starting from the VFS root."
    }];
  optional string type = 3 [(sem_type) = {
      description: "File type."
    }];
  optional StatEntry stat = 11 [(sem_type) = {
      description: "File creation time."
    }];
  optional uint64 age = 5 [(sem_type) = {
      type: "RDFDatetime",
      description: "File age (when file object was updated in GRR)."
    }];
  optional bool is_directory = 6 [(sem_type) = {
      description: "True if the file is a directory."
    }];
  optional Hash hash = 7 [(sem_type) = {
      description: "Hash values of the file."
    }];
  optional uint64 last_collected = 8 [(sem_type) = {
      type: "RDFDatetime",
      description: "Last time file was collected from the client."
    }];
  optional uint64 last_collected_size = 10 [(sem_type) = {
      description: "Size of the file last time it was collected."
    }];
  // Details of an ApiFile.
  optional ApiAff4ObjectRepresentation details = 9 [(sem_type) = {
      description: "The file details."
    }];
}

message ApiGetFileDetailsArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string file_path = 2 [(sem_type) = {
      description: "File path."
    }];
  optional uint64 timestamp = 3 [(sem_type) = {
      type: "RDFDatetime",
      description: "The age specifying which version to retrieve."
    }];
}

message ApiGetFileDetailsResult {
  optional ApiFile file = 1 [(sem_type) = {
      description: "The file containing including all details."
    }];
}

message ApiAff4ObjectRepresentation {
  repeated ApiAff4ObjectType types = 1 [(sem_type) = {
      description: "The list of types."
    }];
}

message ApiAff4ObjectType {
  optional string name = 1 [(sem_type) = {
      description: "The name of the category."
    }];
  repeated ApiAff4ObjectAttribute attributes = 2 [(sem_type) = {
      description: "The list of attributes."
    }];
}

message ApiAff4ObjectAttribute {
  optional string name = 1 [(sem_type) = {
      description: "The name of the attribute."
    }];
  repeated ApiAff4ObjectAttributeValue values = 2 [(sem_type) = {
      description: "The values of the attribute."
    }];
}

message ApiAff4ObjectAttributeValue {
  optional string type = 1 [(sem_type) = {
      description: "The type of the attribute."
    }];
  optional uint64 age = 2 [(sem_type) = {
      type: "RDFDatetime",
      description: "The age of the attribute."
    }];
  optional google.protobuf.Any value = 3 [(sem_type) = {
      description: "The value of the attributes."
      dynamic_type: "GetValueClass"
    }];
}

message ApiListFilesArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string file_path = 2 [(sem_type) = {
      description: "File path."
    }];
  optional int64 offset = 3 [(sem_type) = {
      description: "Starting offset."
    }];
  optional int64 count = 4 [(sem_type) = {
      description: "Max number of items to fetch."
    }];
  optional string filter = 5 [(sem_type) = {
      description: "Return only results whose string representation "
      "contains given substring."
    }];
  optional bool directories_only = 6 [(sem_type) = {
      description: "If true, only directories are returned."
    }];
}

message ApiListFilesResult {
  repeated ApiFile items = 1 [(sem_type) = {
      description: "The list of files."
    }];
}

message ApiGetVfsFilesArchiveArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string file_path = 2 [(sem_type) = {
      description: "File path."
    }];
}

message ApiGetFileTextArgs {
  enum Encoding {
    BASE64_CODEC=0;
    BIG5=1;
    BIG5HKSCS=2;
    CP037=3;
    CP1006=4;
    CP1026=5;
    CP1140=6;
    CP1250=7;
    CP1251=8;
    CP1252=9;
    CP1253=10;
    CP1254=11;
    CP1255=12;
    CP1256=13;
    CP1257=14;
    CP1258=15;
    CP424=16;
    CP437=17;
    CP500=18;
    CP737=19;
    CP775=20;
    CP850=21;
    CP852=22;
    CP855=23;
    CP856=24;
    CP857=25;
    CP860=26;
    CP861=27;
    CP862=28;
    CP863=29;
    CP864=30;
    CP865=31;
    CP866=32;
    CP869=33;
    CP874=34;
    CP875=35;
    CP932=36;
    CP949=37;
    CP950=38;
    IDNA=39;
    ROT_13=40;
    UTF_16=41;
    UTF_16_BE=42;
    UTF_16_LE=43;
    UTF_32=44;
    UTF_32_BE=45;
    UTF_32_LE=46;
    UTF_7=47;
    UTF_8=48;
    UTF_8_SIG=49;
    UU_CODEC=50;
    ZLIB_CODEC=51;
  };
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string file_path = 2 [(sem_type) = {
      description: "File path."
    }];
  optional int64 offset = 3 [(sem_type) = {
      description: "The offset from the start."
    }];
  optional int64 length = 4 [(sem_type) = {
      description: "The number of bytes returned."
    }];
  optional Encoding encoding = 5 [(sem_type) = {
      description: "The encoding of the file."
    }];
  optional uint64 timestamp = 6 [(sem_type) = {
      type: "RDFDatetime",
      description: "The age specifying which version to retrieve."
    }];
}

message ApiGetFileTextResult {
  optional string content = 1 [(sem_type) = {
      description: "The content of the file."
    }];
  optional int64 total_size = 2 [(sem_type) = {
      description: "The total size of the file in byte."
    }];
}

message ApiListKnownEncodingsResult {
  repeated string encodings = 1 [(sem_type) = {
      description: "The list of file encodings."
    }];
}

message ApiGetFileBlobArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string file_path = 2 [(sem_type) = {
      description: "File path."
    }];
  optional int64 offset = 3 [(sem_type) = {
      description: "The offset from the start."
    }];
  optional int64 length = 4 [(sem_type) = {
      description: "The number of bytes returned."
    }];
  optional uint64 timestamp = 5 [(sem_type) = {
      type: "RDFDatetime",
      description: "The age specifying which version to retrieve."
    }];
}

message ApiGetFileVersionTimesArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string file_path = 2 [(sem_type) = {
      description: "File path."
    }];
}

message ApiGetFileVersionTimesResult {
  repeated uint64 times = 1 [(sem_type) = {
      type: "RDFDatetime",
      description: "The list of version times."
    }];
}

message ApiGetFileDownloadCommandArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string file_path = 2 [(sem_type) = {
      description: "File path."
    }];
}

message ApiGetFileDownloadCommandResult {
  optional string command = 1 [(sem_type) = {
      description: "The command to download this file."
    }];
}

message ApiCreateVfsRefreshOperationArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string file_path = 2 [(sem_type) = {
      description: "AFF4 path of a VFS folder to be refreshed."
    }];
  optional uint64 max_depth = 3 [(sem_type) = {
      description: "Maximum recursion depth.",
    }];
  optional bool notify_user = 4  [(sem_type) = {
      description: "Whether the operation should notify the user or not.",
    }];
}

message ApiGetVfsTimelineArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string file_path = 2 [(sem_type) = {
      description: "File path."
    }];
}

message ApiGetVfsTimelineResult {
  repeated ApiVfsTimelineItem items = 1 [(sem_type) = {
      description: "The event items."
    }];
}

message ApiGetVfsTimelineAsCsvArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string file_path = 2 [(sem_type) = {
      description: "File path."
    }];
}

message ApiVfsTimelineItem {
  enum FileActionType {
    MODIFICATION = 0;
    ACCESS = 1;
    METADATA_CHANGED = 2;
  }

  optional uint64 timestamp = 1 [(sem_type) = {
      type: "RDFDatetime",
      description: "The event timestamp."
    }];
  optional string file_path = 2 [(sem_type) = {
      description: "File path."
    }];
  optional FileActionType action = 3 [(sem_type) = {
      description: "File action type."
    }];
}

message ApiCreateVfsRefreshOperationResult {
  optional string operation_id = 1 [(sem_type) = {
      description: "The id of the refresh operation."
    }];
}

message ApiGetVfsRefreshOperationStateArgs {
  optional string client_id = 2 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string operation_id = 1 [(sem_type) = {
      description: "The id of the refresh operation."
    }];
}

message ApiGetVfsRefreshOperationStateResult {
  enum State {
    RUNNING = 0;
    FINISHED = 1;
  }

  optional State state = 1 [(sem_type) = {
      description: "The state of the refresh operation."
    }];
}

message ApiUpdateVfsFileContentArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string file_path = 2 [(sem_type) = {
      description: "AFF4 path of a VFS file to be refreshed."
    }];
}

message ApiUpdateVfsFileContentResult {
  optional string operation_id = 1 [(sem_type) = {
      description: "The id of the update operation."
    }];
}

message ApiGetVfsFileContentUpdateStateArgs {
  optional string client_id = 2 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string operation_id = 1 [(sem_type) = {
      description: "The id of the update operation."
    }];
}

message ApiGetVfsFileContentUpdateStateResult {
  enum State {
    RUNNING = 0;
    FINISHED = 1;
  }

  optional State state = 1 [(sem_type) = {
      description: "The state of the update operation."
    }];
}

message ApiGetPendingUserNotificationsCountResult {
  optional int64 count = 1 [(sem_type) = {
      description: "Number of pending notifications."
    }];
}

message ApiDeletePendingUserNotificationArgs {
  optional uint64 timestamp = 1 [(sem_type) = {
      type: "RDFDatetime",
      description: "The timestamp of the notification to delete."
    }];
}

message ApiListAndResetUserNotificationsArgs {
  optional int64 offset = 2 [(sem_type) = {
      description: "Starting offset."
    }];
  optional int64 count = 3 [(sem_type) = {
      description: "Max number of items to fetch."
    }];
  optional string filter = 4 [(sem_type) = {
      description: "Return only results whose string representation "
      "contains given substring."
    }];
};

message ApiListAndResetUserNotificationsResult {
  repeated ApiNotification items = 1 [(sem_type) = {
      description: "The list of notifications."
    }];
   optional int64 total_count = 2 [(sem_type) = {
      description: "Total count of items."
   }];
}

message ApiListPendingUserNotificationsArgs {
  optional uint64 timestamp = 1 [(sem_type) = {
      type: "RDFDatetime",
      description: "Only notifications after this timestamp "
      "will be returned."
    }];
};

message ApiListPendingUserNotificationsResult {
  repeated ApiNotification items = 1 [(sem_type) = {
      description: "The list of notifications."
    }];
}

message ApiNotification {
  optional uint64 timestamp = 1 [(sem_type) = {
      type: "RDFDatetime",
      description: "Time the notification was added."
    }];
  optional string message = 2 [(sem_type) = {
      description: "The content message of this notification."
    }];
  optional ApiNotificationReference reference = 3 [(sem_type) = {
      description: "The reference of the notification."
    }];
  optional bool is_pending = 4 [(sem_type) = {
      description: "Whether the notification is pending or not."
    }];
}

message ApiNotificationReference {
  option (semantic) = {
    union_field: "type"
  };

  enum Type {
    DISCOVERY = 0 [(description) = "Discovery"];
    HUNT = 3 [(description) = "Hunt"];
    CRON = 4 [(description) = "Cron job"];
    FLOW = 5 [(description) = "Flow"];
    VFS = 6 [(description) = "Virtual file system"];
    CLIENT_APPROVAL = 10 [(description) = "Client approval"];
    HUNT_APPROVAL = 11 [(description) = "Hunt approval"];
    CRON_JOB_APPROVAL = 12 [(description) = "Cron job approval"];
    UNKNOWN = 13 [(description) = "Unknown"];
  }

  optional Type type = 1;

  optional ApiNotificationDiscoveryReference discovery = 2;
  optional ApiNotificationHuntReference hunt = 5;
  optional ApiNotificationCronReference cron = 6;
  optional ApiNotificationFlowReference flow = 7;
  optional ApiNotificationVfsReference vfs = 8;
  optional ApiNotificationClientApprovalReference client_approval = 11;
  optional ApiNotificationHuntApprovalReference hunt_approval = 12;
  optional ApiNotificationCronJobApprovalReference cron_job_approval = 13;
  optional ApiNotificationUnknownReference unknown = 14;
}

message ApiNotificationDiscoveryReference {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "The client this notification is about."
    }];
}

message ApiNotificationFileDownloadReference {
  optional string path = 1 [(sem_type) = {
      type: "RDFURN",
      description: "The download path for the file."
    }];
}

message ApiNotificationHuntReference {
  optional string hunt_urn = 1 [(sem_type) = {
      type: "RDFURN",
      description: "The hunt this notification is about."
    }];
}

message ApiNotificationCronReference {
  optional string cron_job_urn = 1 [(sem_type) = {
      type: "RDFURN",
      description: "The cron job this notification is about."
    }];
}

message ApiNotificationFlowReference {
  optional string client_id = 2 [(sem_type) = {
      type: "ApiClientId",
      description: "The client this notification is about."
    }];
  optional string flow_id = 3 [(sem_type) = {
      type: "ApiFlowId",
      description: "The flow this notification is about."
    }];
}

message ApiNotificationVfsReference {
  optional string vfs_path = 1 [(sem_type) = {
      type: "RDFURN",
      description: "The cron job this notification is about."
    }];
  optional string client_id = 2 [(sem_type) = {
      type: "ApiClientId",
      description: "The client this notification is about."
    }];
}

message ApiNotificationClientApprovalReference {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
    }];
  optional string approval_id = 2;
  optional string username = 3;
}

message ApiNotificationHuntApprovalReference {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId"
    }];
  optional string approval_id = 2;
  optional string username = 3;
}

message ApiNotificationCronJobApprovalReference {
  optional string cron_job_id = 1;
  optional string approval_id = 2;
  optional string username = 3;
}

message ApiNotificationUnknownReference {
  optional string source_urn = 1 [(sem_type) = {
      type: "RDFURN"
    }];
  optional string subject_urn = 2 [(sem_type) = {
      type: "RDFURN"
    }];
};

message ApiListPendingGlobalNotificationsResult {
  repeated GlobalNotification items = 1 [(sem_type) = {
      description: "The list of pending global notifications."
    }];
}

message ApiDeletePendingGlobalNotificationArgs {
  optional GlobalNotification.Type type = 1 [(sem_type) = {
      description: "The type of the global notification to delete."
    }];
}

message ApiClientActionRequest {
  optional uint64 task_id = 1;

  optional uint64 task_eta = 2 [(sem_type) = {
      type: "RDFDatetime",
      description: "This task's lease expiration time."
    }];

  optional string session_id = 3 [(sem_type) = {
      type: "RDFURN"
      description: "Session id that triggered the request."
    }];

  optional string client_action = 4 [(sem_type) = {
      description: "Requested client action name."
    }];

  repeated GrrMessage responses = 5 [(sem_type) = {
      description: "Responses queued for this request."
    }];
}

message ApiListClientActionRequestsArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional bool fetch_responses = 2 [(sem_type) = {
      description: "If true, fetch all the responses for every request."
    }];
}

message ApiListClientActionRequestsResult {
  repeated ApiClientActionRequest items = 1;
}

message ApiGetClientLoadStatsArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];

  optional uint64 start = 2 [(sem_type) = {
      type: "RDFDatetime",
      description: "Fetch client load stats data starting from this "
      "timestamp. If not set, will default to 30 minutes ago."
    }];
  optional uint64 end = 3 [(sem_type) = {
      type: "RDFDatetime",
      description: "Fetch client load stats data from the interval "
      "ending with this timestamp. If not set, will default to the current "
      "time."
    }];

  enum Metric {
    CPU_PERCENT = 0;
    CPU_SYSTEM = 1;
    CPU_USER = 2;

    IO_READ_BYTES = 3;
    IO_WRITE_BYTES = 4;
    IO_READ_OPS = 5;
    IO_WRITE_OPS = 6;

    NETWORK_BYTES_RECEIVED = 7;
    NETWORK_BYTES_SENT = 8;

    MEMORY_PERCENT = 9;
    MEMORY_RSS_SIZE = 10;
    MEMORY_VMS_SIZE = 11;
  }
  optional Metric metric = 5;
}

message ApiGetClientLoadStatsResult {
  repeated ApiStatsStoreMetricDataPoint data_points = 1;
}

message ApiMethod {
  optional string name = 1;
  optional string category = 2;
  optional string doc = 3;

  optional string http_route = 4;
  repeated string http_methods = 5;

  optional ApiRDFValueDescriptor args_type_descriptor = 6;

  enum ResultKind {
    NONE = 0;
    VALUE = 1;
    BINARY_STREAM = 2;
  }
  optional ResultKind result_kind = 7;
  optional ApiRDFValueDescriptor result_type_descriptor = 8;
}

message ApiListApiMethodsResult {
  repeated ApiMethod items = 1;
}

message ApiGrrBinary {
  enum Type {
    PYTHON_HACK = 1;
    EXECUTABLE = 2;
    COMPONENT = 3;
  };
  optional Type type = 1 [(sem_type) = {
      description: "Binary type. Together with path it identifies the binary."
    }];
  optional string path = 2 [(sem_type) = {
      description: "Binary path. Together with binary type it identifies the "
      "binary."
    }];
  optional uint64 size = 3 [(sem_type) = {
      type: "ByteSize",
      description: "Binary size."
    }];
  optional uint64 timestamp = 4 [(sem_type) = {
      type: "RDFDatetime",
      description: "Binary upload timestamp."
    }];
}

message ApiListGrrBinariesResult {
  repeated ApiGrrBinary items = 1;
}

message ApiGetGrrBinaryArgs {
  optional ApiGrrBinary.Type type = 1 [(sem_type) = {
      description: "Binary type."
    }];
  optional string path = 2 [(sem_type) = {
      description: "Binary path."
    }];
}

message ApiGetExportedFlowResultsArgs {
  optional string client_id = 1 [(sem_type) = {
      type: "ApiClientId",
      description: "Client id."
    }];
  optional string flow_id = 2 [(sem_type) = {
      type: "ApiFlowId",
      description: "Flow id."
    }];
  optional string plugin_name = 3 [(sem_type) = {
      description: "Instant output plugin name."
    }];
}

message ApiGetExportedHuntResultsArgs {
  optional string hunt_id = 1 [(sem_type) = {
      type: "ApiHuntId",
      description: "Hunt id."
    }];
  optional string plugin_name = 2 [(sem_type) = {
      description: "Instant output plugin name."
    }];
}

//
// API call routers parameters.
//
message ApiLabelsRestrictedCallRouterParams {
  repeated string labels_whitelist = 1;
  repeated string labels_owners_whitelist = 2;

  optional bool allow_flows_access = 3;
  optional bool allow_vfs_access = 4;
}

message RobotRouterSearchClientsParams {
  optional bool enabled = 1;
}

message RobotRouterFileFinderFlowParams {
  optional bool enabled = 1;

  optional bool globs_allowed = 2 [(sem_type) = {
      description: "If false, using '*' in FileFinder paths is not allowed."
    }];

  optional bool interpolations_allowed = 3 [(sem_type) = {
      description: "If false, using interpolations in FileFinder is not "
      "allowed."
    }];

  optional string file_finder_flow_name = 4 [(sem_type) = {
      description: "Name of the flow to use. Must be interface-compatible "
      "with FileFinder. Default is 'FileFinder'."
    }];

  optional uint64 max_flows_per_client_daily = 5 [(sem_type) = {
      description: "Maximum number of FileFinder flows that can be started on a "
      "single client within 24 hours. Default is 0, meaning no limit."
    }];
  optional uint64 min_interval_between_duplicate_flows = 6 [(sem_type) = {
      type: "Duration",
      description: "Minimum time that has to pass between 2 FileFinder flows "
      "with same arguments. Default is 0, meaning any time."
    }];

  optional uint64 max_file_size = 7 [(sem_type) = {
      description: "Maximum file size in bytes. Will be enforced for all "
      "FileFinder actions. Files bigger than max_file_size will be skipped."
    }];
}

message RobotRouterArtifactCollectorFlowParams {
  optional bool enabled = 1;

  repeated string artifacts_whitelist = 2 [(sem_type) = {
      description: "Only artifacts from this whitelist can be collected. "
      "Empty list means no artifacts can be collected."
    }];

  optional string artifact_collector_flow_name = 3 [(sem_type) = {
      description: "Name of the flow to use. Must be interface-compatible "
      "with CollectArtifacts."
    }];

  optional uint64 max_flows_per_client_daily = 5 [(sem_type) = {
      description: "Maximum number of ArtifactCollectorFlow flows that can be "
      "started on a single client within 24 hours. Default is 0, meaning no "
      "limit."
    }];
  optional uint64 min_interval_between_duplicate_flows = 6 [(sem_type) = {
      type: "Duration",
      description: "Minimum time that has to pass between 2 "
      "ArtifactCollectorFlow flows with same arguments. Default is 0, "
      "meaning any time."
    }];
}

message RobotRouterGetFlowParams {
  optional bool enabled = 1;
}

message RobotRouterListFlowResultsParams {
  optional bool enabled = 1;
}

message RobotRouterGetFlowFilesArchiveParams {
  optional bool enabled = 1;

  repeated string path_globs_blacklist = 2 [(sem_type) = {
      type: "GlobExpression",
      description: "Only files not matching these globs will be included "
      "into the archive. Blacklist is always applied first. Files not "
      "matching the blacklist should still match the whitelist."
    }];

  repeated string path_globs_whitelist = 3 [(sem_type) = {
      type: "GlobExpression",
      description: "Only files matching these globs will be included into "
      "the archive. Whitelist is applied after the blacklist."
    }];

  optional bool skip_glob_checks_for_artifact_collector = 4;
}

message ApiCallRobotRouterParams {
  optional RobotRouterSearchClientsParams search_clients = 1;

  optional RobotRouterFileFinderFlowParams file_finder_flow = 2;
  optional RobotRouterArtifactCollectorFlowParams artifact_collector_flow = 3;

  optional RobotRouterGetFlowParams get_flow = 4;
  optional RobotRouterListFlowResultsParams list_flow_results = 5;
  optional RobotRouterGetFlowFilesArchiveParams get_flow_files_archive = 6;

  optional string robot_id = 7;
}
